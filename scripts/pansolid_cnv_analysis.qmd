---
title: "PanSolid CNV Analysis"
author: "Joe Shaw"
date: "`r Sys.Date()`"
format: html
editor: visual
---

## Introduction

This Quarto document is a notebook for organising analysis of somatic CNVs from a CLC Genomics Workbench pipeline (Qiagen).

The sections and analysis in this document should correspond to the Word document "Pan Solid CLC Somatic Amplifications Validation Document.docx" saved on the S drive.

```{r}
#| label: packages
#| include: FALSE

library(tidyverse)
library(readxl)
library(here)
library(odbc)
library(DBI)
library(dbplyr)
library(ggpubr)

source(here::here("functions/cnv_functions.R"))

```

```{r}
#| label: dlms-connection
#| include: FALSE

dbi_con <- DBI::dbConnect(
  drv = odbc::odbc(),
  dsn = "moldb")

```

## Primer Overlap Between Core and PanSolid

Primer spreadsheets were provided by Qiagen.

```{r}
#| label: primers
#| echo: FALSE

pan_solid_only <- read_excel(here::here("data/Primer and Gene Comparison.xlsx"),
                             sheet = "Primer Overlap",
                             range = "A2:D11024",
                             col_names = c("chromosome", "coordinates", "sequence",
                                           "gene"),
                             col_types = c("text", "text", "text", "text")) |> 
  mutate(category = "Unique to 44038Z-11379",
         text = "PanSolid only")

core_only <- read_excel(here::here("data/Primer and Gene Comparison.xlsx"),
                        sheet = "Primer Overlap",
                        range = "G2:J595",
                        col_names = c("chromosome", "coordinates", "sequence",
                                      "gene"),
                        col_types = c("text", "text", "text", "text")) |> 
  mutate(category = "Unique to 17500Z-950",
         text = "Core only")

stopifnot(intersect(pan_solid_only$sequence, core_only$sequence) == 0)

both_panels <- read_excel(here::here("data/Primer and Gene Comparison.xlsx"),
                          sheet = "Primer Overlap",
                          range = "L2:O357",
                          col_names = c("chromosome", "coordinates", "sequence",
                                        "gene"),
                          col_types = c("text", "text", "text", "text")) |> 
  mutate(category = "common to both 44038Z-11379 and 17500Z-950",
         text = "Both")

all_primers <- rbind(pan_solid_only, core_only, both_panels) |> 
  mutate(gene_clean = case_when(
    
    gene == "ERBB2, MIR4728" ~"ERBB2",
    gene == "EGFR, EGFR-AS1" ~"EGFR",
    TRUE ~gene)) 

primer_plot <- all_primers |> 
  filter(gene_clean %in% c("ERBB2", "EGFR", 
                           "MYC", "MET", "ARID1A", "SUFU")) |> 
  ggplot(aes(x = text, y = , fill = text)) +
  geom_bar() +
  theme(legend.title = element_blank()) +
  facet_wrap(~gene_clean) +
  labs(x = "", y = "Number of primers", 
       title = "EGFR, ERBB2 and MET share primers between Pan Solid and Core")

primer_plot

primer_table <- all_primers |> 
  filter(gene %in% c("ERBB2", "EGFR", "MET")) |>
  filter(text != "Core only") |> 
  group_by(gene_clean, text) |> 
  summarise(total = n()) |> 
  mutate(prop = round(total/sum(total) * 100, 1)) |> 
  ungroup() |> 
  pivot_wider(names_from = c(text),
              values_from = c(total, prop)) |> 
  arrange(desc(total_Both))

primer_table_formatted <- primer_table |> 
  rename(Gene = gene_clean,
         "Primers shared with Core panel" = total_Both,
         "Primers shared with Core panel (%)" = prop_Both,
         "Primers unique to PanSolid" = "total_PanSolid only",
         "Primers unique to PanSolid (%)" = "prop_PanSolid only") |> 
  select(Gene, "Primers shared with Core panel",
         "Primers shared with Core panel (%)",
         "Primers unique to PanSolid",
         "Primers unique to PanSolid (%)")

knitr::kable(primer_table_formatted)

export_timestamp(primer_table_formatted)

```

```{r}
#| label: load-results
#| include: FALSE

coarse_tab <- "Oncogenes (Amplified) Coars..."
fine_tab <- "Oncogenes (Amplified) Fine-..."

datapath <- "S:/central shared/Genetics/NGS/Bioinformatics/1_Pan-solid-Cancer/CNV/00_Amplifications_Fine_vs_Coarse/"

negatives_path <- str_c(datapath, "Negatives/")

all_files <- flatten(list(
  
  list.files(str_c(datapath, "CNS_PS/"), full.names = TRUE),
  
  list.files(str_c(datapath, "M1_CRC_PS/"), full.names = TRUE),
  
  list.files(str_c(datapath, "M3_BREAST_PS/"), full.names = TRUE),
  
  list.files(str_c(datapath, "M4_LUNG_PS/"), full.names = TRUE),
  
  list.files(str_c(negatives_path, "CNS_PS/"), full.names = TRUE),

  list.files(str_c(negatives_path, "M1_CRC_PS/"), full.names = TRUE),
  
  list.files(str_c(negatives_path, "M3_BREAST_PS/"), full.names = TRUE),
  
  list.files(str_c(negatives_path, "M4_LUNG_PS/"), full.names = TRUE),
  
  list.files(str_c(negatives_path, "SchwannCNS_PS/"), full.names = TRUE)))

collated_coarse <- all_files |>
  map(\(all_files) summarise_results(
    file = all_files,
    input_sheet = coarse_tab
  )) |>
  list_rbind() |> 
  filter(suffix == "_") |> 
  distinct()

```

## Samples

Sample details are extracted from DLMS.

```{r}
#| label: sample-extractions
#| echo: FALSE

extraction_methods <- tbl(dbi_con, dbplyr::in_catalog(catalog = "MolecularDB",
                    schema = "dbo",
                    table = "MOL_ExtractionMethods")) |> 
  # Have to remove large columns to avoid Invalid Descriptor Index error
  select(-c(Checks, Reagents)) |> 
  collect()

extraction_tbl <- tbl(dbi_con, dbplyr::in_catalog(catalog = "MolecularDB",
                    schema = "dbo",
                    table = "MOL_Extractions"))

extraction_batch_tbl <- tbl(dbi_con, dbplyr::in_catalog(catalog = "MolecularDB",
                    schema = "dbo",
                    table = "MOL_ExtractionBatches"))

samples_tested <- unique(collated_coarse$sample)

extraction_batches <- extraction_tbl |> 
  filter(LabNo %in% samples_tested) |> 
  collect()

batches <- unique(extraction_batches$ExtractionBatchFK)

extraction_batch_info <- extraction_batch_tbl |> 
  filter(ExtractionBatchId %in% batches) |> 
  # Remove DNA dilutions
  filter(ExtractionMethodFK != 11) |> 
  collect() |> 
  left_join(extraction_methods, join_by(ExtractionMethodFK == ExtractionMethodId))

extraction_batch_table <- extraction_batch_info |> 
  count(MethodName)

knitr::kable(extraction_batch_table)

```

```{r}
#| label: sample-types
#| echo: FALSE

sample_tbl <- tbl(dbi_con, dbplyr::in_catalog(catalog = "MolecularDB",
                    schema = "dbo",
                    table = "Samples"))

tissue_types <- tbl(dbi_con, dbplyr::in_catalog(catalog = "MolecularDB",
                    schema = "dbo",
                    table = "TissueTypes")) |> 
  collect() |> 
  janitor::clean_names()

sample_info <- sample_tbl |> 
  select(-c(StatusComment, COMMENTS, ConsultantAddress, ADDRESS1)) |> 
  filter(LABNO %in% samples_tested) |> 
  collect() |> 
  janitor::clean_names() |> 
  mutate(tissue = as.numeric(tissue)) |> 
  left_join(tissue_types, join_by(tissue == tissue_type_id))

sample_type_summary <- sample_info |> 
  count(tissue_type) |> 
  arrange(desc(n))

knitr::kable(sample_type_summary)

```

## Results

I've taken the PanSolid CLCL results from the output of the CLC pipeline on the "coarse" setting. If an output Excel had a CNV call for a particular gene, I classified that as an amplification, without any filtering on coordinates or fold change.

In total there are **`r length(all_files)`** CLC outputs for **`r length(unique(collated_coarse$sample))`** samples tested. I have excluded replicates of samples demarcated with a, b and c suffixes, and samples tested on more than one worksheet.

Every CNV call has a fold-change of at least 2.5, which is a copy number of at least 5. So treating every call as an amplification seems to be a fair assumption.

```{r}
#| label: load-calls
#| include: FALSE

coarse_calls <- all_files |>
  map(\(all_files) read_clc_excel(
    file = all_files,
    input_sheet = coarse_tab
  )) |>
  list_rbind() |> 
  mutate(setting = "coarse")  

fine_calls <- all_files |>
  map(\(all_files) read_clc_excel(
    file = all_files,
    input_sheet = fine_tab
  )) |>
  list_rbind() |> 
  mutate(setting = "fine")

all_calls <- rbind(coarse_calls, fine_calls)

all_calls$gene

```

Amplifications were called in **`r length(unique(all_calls$gene))`** genes, with a wide spread of fold changes.

```{r}
#| label: fold-change-spread
#| echo: FALSE
fc_plot <- all_calls |> 
  ggplot(aes(x = reorder(sample, fold_change_adjusted), y = fold_change_adjusted)) +
  geom_point(aes(colour = gene), alpha = 0.5, size = 3) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(x = "", title = "Fold changes for CNV calls") +
  geom_hline(yintercept = 2.5, linetype = "dashed") +
  facet_wrap(~setting)

fc_plot

```

For the Core panel, I've directly queried DLMS and extracted the CNV results from the free-type "Genotype" field. 

```{r}
#| label: core-results
#| include: FALSE

results_tbl <- tbl(dbi_con, 
                   dbplyr::in_catalog(
                     catalog = "MolecularDB",
                     schema = "dbo",
                     table = "ResultsAccess"))

sample_ids <- unique(collated_coarse$sample)

core_result_info <- results_tbl |> 
  select(LABNO, TEST, TESTTYPE, Genotype, Genotype2, GENOCOMM) |> 
  filter(LABNO %in% sample_ids) |> 
  collect() |> 
  filter(TEST %in% grep(pattern = "Q.{2,4}seq.+core", x = TEST, ignore.case = TRUE,
                        value = TRUE)) |> 
  mutate(Genotype = case_when(
    
    # Sample has "EGFR" instead of "ERBB2" written on DLMS - confirmed on report
    LABNO == 23022389 ~"ERBB2 amplification detected (Mean DQ 25x)",
    
    # Sample has "ERRB2" instead of "ERBB2" written
    LABNO == 21015264 ~"No mutation identified; ERBB2 amplification detected (mean DQ 60.41x)",
    
    TRUE ~Genotype)) |> 
  
  filter(!duplicated(LABNO))
  
core_cnv_calls <- rbind(extract_cnv_calls(df = core_result_info, input_gene = "EGFR"),
                        extract_cnv_calls(df = core_result_info, input_gene = "ERBB2"), 
                        extract_cnv_calls(df = core_result_info, input_gene = "MET")) 
    
joined <- collated_coarse |> 
  filter(sample %in% core_result_info$LABNO) |> 
  left_join(core_cnv_calls,
            join_by(sample == LABNO, gene == gene_searched)) |> 
  mutate(outcome = case_when(
           
           result == "Amplification" & core_result  == "Amplification" ~"true positive",
           
           result == "No call" & core_result  == "No call" ~"true negative",
           
           result == "Amplification" & core_result  == "No call" ~"false positive",
           
           result == "No call" & core_result  == "Amplification" ~"false negative",

           TRUE ~"no match"
           
         ))

egfr_conf <- draw_confusion_matrix("EGFR")

erbb2_conf <- draw_confusion_matrix("ERBB2")

met_conf <- draw_confusion_matrix("MET")

export_timestamp(egfr_conf)

export_timestamp(erbb2_conf)

export_timestamp(met_conf)

```

## EGFR Results

```{r}
#| label: egfr
#| echo: FALSE
knitr::kable(egfr_conf)

```

## ERBB2 Results

```{r}
#| label: erbb2
#| echo: FALSE
knitr::kable(erbb2_conf)

```

## MET Results

There is 1 sample where a MET amplification was detected on PanSolid but not on Core.

In the original validation of the Dosage Quotient method, no samples were included which had MET amplifications detected by a different method.

```{r}
#| label: met
#| echo: FALSE
knitr::kable(met_conf)

```

There were no cases where an amplification was called only on one setting.

```{r}
#| label: fine-vs-coarse
#| echo: FALSE

all_calls |> 
  filter(name %in% c("EGFR", "ERBB2", "MET")) |> 
  ggplot(aes(x = reorder(sample, cnv_region_length), y = cnv_region_length)) +
  geom_point() +
  theme(axis.text.x = element_text(angle = 90)) +
  facet_wrap(~setting)

plot_coarse_v_fine <- function(input_gene) {
  
  plot <- all_calls |> 
    filter(name == input_gene) |> 
    group_by(sample, setting) |> 
    summarise(calls = n()) |> 
    ggplot(aes(x = sample, y = calls)) +
    geom_col(aes(fill = setting), position = "dodge") +
    labs(title = as.character(input_gene))
  
  return(plot)
  
}

egfr_p <- plot_coarse_v_fine("EGFR")

erbb2_p <- plot_coarse_v_fine("ERBB2")

met_p <- plot_coarse_v_fine("MET")

ggarrange(egfr_p, erbb2_p, met_p, ncol = 1)

```

```{r}

cnv_coord_regex <- regex(
  r"[
  \D{0,11}       # Either 0 or 11 non-digit characters. 11 is "complement("
  (\d{1,10})    # first coordinate number (1 to 10 digits)
  \.\.          # two full stops
  (\d{1,10})  # second coordinate number (1 to 10 digits)
  ]",
  comments = TRUE
)

call_coord <- coarse_calls |> 
  mutate(cnv_start = as.numeric(str_extract(string = cnv_region, 
                                            pattern = cnv_coord_regex, 
                                            group = 1)),
         cnv_end = as.numeric(str_extract(string = cnv_region, 
                                          pattern = cnv_coord_regex, 
                                          group = 2))) 


coord_long <- call_coord |> 
  select(sample, gene, cnv_start, cnv_end, fold_change_adjusted) |> 
  pivot_longer(cols = -c(sample, gene, fold_change_adjusted),
               names_to = "category",
               values_to = "coordinate")

coord_long |> 
  filter(gene == "EGFR") |> 
  ggplot(aes(x = coordinate, y = sample)) +
  geom_line(aes(colour = fold_change_adjusted)) +
  geom_vline(xintercept = 55019017, linetype = "dashed") +
  geom_vline(xintercept = 55211628, linetype = "dashed")

coord_long |> 
  filter(gene == "ERBB2") |> 
  ggplot(aes(x = coordinate, y = fold_change_adjusted)) +
  geom_line(size = 2, alpha = 0.5) +
  geom_vline(xintercept = 39688094, linetype = "dashed") +
  geom_vline(xintercept = 39728658, linetype = "dashed") +
  facet_wrap(~sample) +
  ylim(0, 60)

coord_long |> 
  filter(gene == "EGFR") |> 
  #filter(sample == 23038490) |> 
  ggplot(aes(x = coordinate, y = fold_change_adjusted)) +
  geom_line(size = 2, alpha = 0.5) +
  geom_vline(xintercept = 55019017, linetype = "dashed") +
  geom_vline(xintercept = 55211628, linetype = "dashed") +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5)) +
  facet_wrap(~sample)

coord_long |> 
  filter(gene == "MET") |> 
  ggplot(aes(x = coordinate, y = fold_change_adjusted)) +
  geom_line(size = 2, alpha = 0.5) +
  geom_vline(xintercept = 116672196, linetype = "dashed") +
  geom_vline(xintercept = 116798377, linetype = "dashed") 


```

