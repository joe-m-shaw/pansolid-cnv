---
title: "DOC6567: Validation of Detecting Somatic Gene Deletions and Ploidy States 
with the PanSolid CLC pipeline"
format: 
  docx:
    reference-doc: north_west_glh_document_template.docx
    link-citations: true
toc: true
toc-title: "Table of Contents"
bibliography: pansolid_cnv_references.bib
csl: harvard-manchester-metropolitan-university.csl
fig-align: "left"
fig-wdith: 6
---

{{< pagebreak >}}

# Authors

Author: Joe Shaw (CS20980)

Project Lead(s): Joe Shaw, Elizabeth Sollars, Eleanor Baker, Helene Schlecht,
George Burghel

Date: `r Sys.Date()`

Author contact: joseph.shaw2\@mft.nhs.uk; joseph.shaw3\@nhs.net

{{< pagebreak >}}

# Acronyms

**BAF:** B Allele Frequency

**CDKN2A**: Cyclin Dependent Kinase iNhibitor 2A

**CDKN2B**: Cyclin Dependent Kinase iNhibitor 2B

**CGH:** Comparative Genome Hybridisation

**CIN:** Chromosomal Instability

**CLC**: Acronym unknown. CLC Bio was acquired by Qiagen in 2013.

**CNA:** Copy Number Alteration

**CNV**: Copy Number Variant

**COSMIC:** Catalogue of Somatic Mutations in Cancer

**ddPCR**: droplet digital Polymerase Chain Reaction

**DNA**: DeoxyriboNucleic Acid

**FFPE**: Formalin-Fixed Paraffin Embedded

**FISH**: Fluorescent In-Situ Hybridisation

**GLH**: Genomic Laboratory Hub

**HMM**: Hidden Markov Model

**IHC**: Immuno-HistoChemistry

**LOH**: Loss Of Heterozygosity

**MMR**: MisMatch Repair

**NCC**: Neoplastic Cell Content

**NGS**: Next Generation Sequencing

**NHS**: National Health Service

**p14ARF**: protein 14 kilo Daltons Alternate Reading Frame

**p15INK4B**: protein 15 kilo Daltons Inhibitor of CDK4 B

**p16INK4A**: protein 16 kilo Daltons Inhibitor of CDK4 A

**PTEN**: Phosphatase and tensin homolog deleted on chromosome ten

**SNP:** Single Nucleotide Polymorphism

**TSG:** Tumour Suppressor Gene

**WGS**: Whole Genome Sequencing

**WHO**: World Health Organisation

{{< pagebreak >}}

```{r}
#| label: packages-and-functions
#| warning: FALSE
#| include: FALSE

library(tidyverse)
library(knitr)
library(here)
library(janitor)
library(readxl)
library(patchwork)
library(foldchanger)

source(here("functions/gene_table_functions.R"))
source(here("functions/test_metric_functions.R"))
source(here("functions/uom_functions.R"))
source(here("functions/extract_pansolid_cnv_coordinates.R"))
source(here("functions/cnv_plot_functions.R"))
source(here("functions/transcript_functions.R"))
source(here("functions/pansolid_cnv_excel_functions.R"))

```

```{r}
#| label: source-scripts
#| warning: FALSE
#| include: FALSE

# source(here("scripts/del_val_collate_wgs_htmls.R"))

# source(here("scripts/del_val_collate_ddpcr_csvs.R"))

# source(here("scripts/del_val_collate_pansolid_results.R"))

# source(here("scripts/del_val_get_patient_info.R"))

# source(here("scripts/del_val_get_nf2_loh_results.R"))

# rm(list=ls())

source(here("scripts/del_val_load_processed_data.R"))

```

```{r}
#| label: thresholds-and-folderpaths
#| include: FALSE

data_folderpath <- config::get("data_folderpath")

image_folderpath <- paste0(data_folderpath,
                           "validation/DOC6567_deletions/images/")

deletion_fc_threshold_theoretical <- pred_fc(tumour_cpc = 1, 
                                             ncc = 50, dir = "loss",
                                             digits = 3)

deletion_fc_threshold <- -1.25

percent_138x_qc_threshold <- 75

noise_qc_threshold <- 0.7

loh_genes <- c("MSH2", "MSH6", "MLH1", "PMS2", "LZTR1", "SMARCB1", "NF2")

```

```{r}
#| label: tbl-modifications
#| include: FALSE

analyst_comment_regex <- "(.*);\\s(.*)"

del_val_collated_del_genes <- del_val_collated_del_genes |> 
  mutate(pansolid_result = case_when(
    min_region_fold_change <= deletion_fc_threshold ~"deletion",
    min_region_fold_change > deletion_fc_threshold ~"no deletion"
  ))

stopifnot(length(setdiff(unique(del_val_collated_del_genes$pansolid_result),
                         c("no deletion", "deletion"))) == 0)

del_val_collated_sig_cnvs <- del_val_collated_sig_cnvs |> 
  mutate(comment_present = str_detect(string = check_1,
                                      pattern = ";"),
        analyst_result = case_when(
          comment_present == TRUE ~str_extract(string = check_1,
                                      pattern = analyst_comment_regex,
                                      group = 1),
          comment_present == FALSE ~check_1
        ),
        analyst_comment = str_extract(string = check_1,
                                      pattern = analyst_comment_regex,
                                      group = 2))

# Check all detected CNVs have been manually reviewed
stopifnot(nrow(del_val_collated_sig_cnvs |> 
  filter(consequence != "no call" &
           is.na(analyst_result))) == 0)

sig_cnvs_with_manual_review <- del_val_collated_sig_cnvs |> 
  filter(consequence != "no call")

# Check consistent terminology has been used
stopifnot(length(setdiff(unique(sig_cnvs_with_manual_review$analyst_result),
        c("deletion", "no deletion",
            "amplification", "no amplification",
            "fail"))) == 0)

del_val_collated_loh <- del_val_collated_loh |> 
  mutate(comment_present = str_detect(string = check_1,
                                      pattern = ";"),
        analyst_result = case_when(
          comment_present == TRUE ~str_extract(string = check_1,
                                      pattern = analyst_comment_regex,
                                      group = 1),
          comment_present == FALSE ~check_1
        ),
        analyst_comment = str_extract(string = check_1,
                                      pattern = analyst_comment_regex,
                                      group = 2))

stopifnot(anyNA(del_val_collated_loh$analyst_result) == FALSE)

stopifnot(length(setdiff(unique(del_val_collated_loh$analyst_result),
                         c("no LOH", "LOH", "fail"))) == 0)

del_val_sample_patient_info <- del_val_sample_patient_info |> 
  mutate(pathno = case_when(
    # Pathology number incorrectly entered on DNA Database - checked
    # against referral form
    labno == "23013975" ~"NB23-145",
    TRUE ~pathno
  ))

```

```{r}
#| label: targets
#| include: FALSE
#| warning: FALSE

target_df <- read_csv(paste0(data_folderpath,
                             "validation/DOC6283_amplifications/bed_files/",
                             "PanSolidv2_GRCh38_noalt_BED.csv")) |> 
  clean_names() |> 
  mutate(target_type = case_when(
    
    grepl(x = name, 
          pattern =  "chr(\\d{1,2}|X):\\d{1,3}.+") == TRUE ~"genomic backbone",
    TRUE ~"gene target"
  ))

target_df_with_coordinates <- extract_pansolid_cnv_coordinates(target_df, 
                                                               region) |> 
  mutate(target_size_bp = abs(end-start))

del_genes <- unique(del_val_collated_del_genes$gene)

pansolid_target_loci <- target_df |> 
  mutate(single_locus = str_split(name, pattern = ";")) |> 
  unnest(single_locus) 

gene_target_counts <- pansolid_target_loci |> 
  filter(single_locus %in% del_genes) |> 
  count(single_locus) |>
  # Some genes have SNP backbone targets within them, which don't contain
  # the gene name but do contribute to CNV calling within the gene
  mutate(n = case_when(
    single_locus == "CDKN2A" ~14,
    single_locus == "PMS2" ~16,
    single_locus == "TP53" ~15,
    TRUE ~n
  )) |> 
  mutate("CLC setting" = case_when(
    n < 10 ~"Fine",
    n >= 10 & single_locus != "CDKN2A" ~"Coarse",
    # CDKN2A on fine due to small NM_000077.5	transcript
    single_locus == "CDKN2A" ~"Fine"
  )) |> 
  rename("Number of PanSolid targets" = n,
         "Gene" = single_locus) 

```

# Purpose

The purpose of this document is to describe the validation of detection of
somatic gene deletions and ploidy states
with the PanSolid v2 QIAseq enrichment panel using the PanSolid CLC 
pipeline (v2.4) at the North West Genomic Laboratory Hub (GLH).

# Executive Summary

Manual review of CNV calls by a trained staff member is required.

# Introduction

This validation is the final part of the project to validate copy number
variants (CNVs) on the PanSolid enrichment panel, and builds on the previous
validations described in @tbl-previous-validations. Currently, detection of 
gene deletions and loss of heterozygosity (LOH) is 
performed on the "Core" and "Merged" QIAseq primer enrichments for different
tumour types. By validating detection of these variants on the PanSolid 
enrichment, this project aims to replace these enrichments with 
PanSolid. Overall, the aim is to streamline testing of 
solid tumours at the 
North West GLH, and to expand the list of genes and variant types detected.

```{r}
#| label: tbl-previous-validations
#| tbl-cap: "Validations of the PanSolid enrichment and pipeline"
#| echo: FALSE

prev_validation_table <- tribble(
  ~`Description`, ~`Document number`, ~`Date`,
  "Detection of single nucleotide variants and indel variants", "DOC6024 v1", "July 2023",
  "Verification of PanSolid enrichment version 2", "DOC6024 v3", "April 2024",
  "Detection of amplifications in *ERBB2*", "DOC6260", "April 2024",
  "Detection of amplifications in 8 additional genes", "DOC6283", "November 2024",
  "Detection of gene deletions and ploidy states", "DOC6567", "April 2025"
)

kable(prev_validation_table)

```

## Gene deletions and ploidy states

Somatic copy number changes are a common pathogenic mechanism in cancers [@li2020],
leading to the amplification of expression from proto-oncogenes (addressed in
[DOC6260]{custom-style="Strong"} and 
[DOC6283]{custom-style="Strong"}) and the reduction or ablation of expression
from tumour suppressor genes (TSGs) (addressed in this validation document).
The loss of expression from a TSG leads to cancer development via a recessive
two-hit mechanism, requiring two
events to inactivate both TSG alleles [@knudson1971]. 

Loss of TSG expression can occur through the physical loss of a TSG copy from 
a cell's genome, which may be due to a focal deletion
of the gene locus or as part of a much larger chromosomal change, such as
aneuploidy for a whole chromosome or chromosome arm. Certain cancers have
specific recurrent aneuploidies leading to TSG loss, such as monosomy of 
chromosome 10 in glioblastoma [@boström1998] leading to
loss of *PTEN*, and monosomy of chromosome 22 in meningioma [@neill2020]
leading to loss of *NF2*. Different combinations of allelic copy numbers at the
gene, chromosome or whole genome level are described as different 
ploidy states (@tbl-clc-ploidy-states).

Other mechanisms of loss of TSG expression include 
pathogenic sequence variants, epigenetic silencing, different types of CNV such as 
duplications [@li2020], and copy-neutral LOH.
Copy-neutral LOH arises when a cell repairs DNA damage to a particular allele 
of a gene by copying the other allele.
If the allele used
for the repair contains a deleterious variant, such as a pathogenic sequence 
variant or a gene deletion, the genotype of the cell changes
from being monoallelic for the variant to being biallelic. Copy-neutral LOH
is a frequent pathogenic mechanism in multiple cancer types, including
colorectal cancer [@melcher2007], and is similar but distinct from the copy-loss
LOH which accompanies a gene deletion. In this way, LOH is an attribute of 
particular ploidy states, as shown in @tbl-clc-ploidy-states,
which is reproduced from the 
[Qiagen CLC manual](https://resources.qiagenbioinformatics.com/manuals/biomedicalgenomicsanalysis/2400/index.php?manual=Detect_Regional_Ploidy.html).

```{r}
#| label: tbl-clc-ploidy-states
#| tbl-cap: "Ploidy states"
#| echo: FALSE

tbl_clc_ploidy_states <- tribble(
  ~State, ~`Allele ratio`, ~`Copy number`, ~`LOH`,
  "Normal diploid", "1:1", "2", "No",
  "Deletion", "0:1", "1", "Yes (copy-loss LOH)",
  "Bi-allelic deletion", "0:0", "0", "No",
  "Uniparental disomy", "0:2", "2", "Yes (copy-neutral LOH)",
  "Duplication", "1:2", "3", "No",
  "Whole genome duplication", "2:2", "4", "No"
)

kable(tbl_clc_ploidy_states)

```

Different mechanisms of loss of TSG expression can combine within the same
cell to cause cancer. One example is the common inactivation of the 
*TP53* gene through a
missense variant on one allele and a mono-allelic loss of
chromosome 17p on the other allele [@bendavid2020; @levine2020]. 
Conversely, a gene loss may be due to a 
biallelic event, such as the recurrent focal bi-allelic deletion of 
the *CDKN2A* and *CDKN2B* genes in
central nervous system tumours [@louis2021].

## Germline variants

Gene deletions can occur in somatic tissues, or
may be found in a patient's germline, which increases the likelihood of 
developing cancer. For example, germline deletions in the DNA mis-match repair
(MMR)  genes *MLH1*, *MSH2*, *MSH6* and *PMS2* cause an increased risk of 
colorectal cancer, referred to as Lynch syndrome, whilst deletions in the 
*NF2* gene cause *NF2*-related Schwannomatosis [@hadfield2010].
Therefore, when a deleterious TSG variant, such as a deletion, is 
detected in tumour sample, reflex testing of lymphocyte DNA can identify if the
variant is present in the patient's germline, which would warrant 
screening for future cancer development. In addition, detection of copy-neutral 
LOH at a TSG locus within a tumour
can be helpful when no germline variant has been found, as it provides further 
evidence that the cancer has arisen sporadically, rather than through an
undetected germline predisposition.

## Target genes

The aim of this validation was to detect deletions in 
`r length(unique(del_val_collated_del_genes$gene))`
TSGs on the PanSolid v2 QIAseq enrichment (Supplementary Information,
@tbl-deletion-gene-targets). These genes were
selected based on the specifications of the 
[NHS Genomic Test Directory for Cancer](https://www.england.nhs.uk/publication/national-genomic-test-directories/). Ploidy state was determined for 
`r length(loh_genes)`
genes involved with inherited 
predisposition to colorectal tumours (*MSH2*, *MSH6*, *MLH1* and *PMS2*) and
Schwannomas (*LZTR1*, *SMARCB1* and *NF2*). 

For gene deletions there was a 
particular focus on *CDKN2A*, *CDKN2B* 
and *PTEN*, as these 
deletions are frequently found in glioblastoma samples, which comprised the
main tumour type in the testing cohort.

### *CDKN2A* and *CDKN2B*

The *CDKN2A* and *CDKN2B* genes are adjacent to each other on chromosome 9,
separated by roughly 20 kilobases (kb). The *CDKN2A* gene encodes 2 key
transcripts which produce two separate proteins: p16INK4a and p14ARF 
[@quelle1995] (@tbl-cdkn2a-details). Both proteins have
important roles in cell growth regulation, and deletion of *CDKN2A* 
contributes to tumour proliferation [@appay2019]. 

```{r}
#| label: tbl-cdkn2a-details
#| tbl-cap: "CDKN2A and CDKN2B details"
#| echo: FALSE

tbl_cdkna_details <- tibble::tribble(
  ~"Gene",	~"Ensembl", ~"Refseq", 	~"Coordinates (GRCh38)", ~start	, ~end, ~"Protein", ~"PanSolid targets",
  "CDKN2A",	"ENST00000304494.10",	"NM_000077.5",	"21967752-21974857",	21967752,	21974857,	"p16INK4a",	5,
  "CDKN2A",	"ENST00000579755.2",	"NM_058195.4"	, "21967752-21994392",	21967752,	21994392,	"p14ARF",	14,
  "CDKN2B",	"ENST00000276925.7",	"NM_004936.4",	"22002903-22009305",	22002903,	22009305,	"p15INK4B",	2) |> 
  mutate(length_kb = round(abs(end-start)/1000, 1)) |> 
  select(-c(start, end)) |> 
  relocate(length_kb, .after = "Coordinates (GRCh38)") |> 
  rename("Legnth (kb)" = length_kb)

kable(tbl_cdkna_details)

```

```{r}
#| label: cdkn2a-transcript-tbl
#| include: FALSE

transcript_folder <- paste0(config::get("data_folderpath"),
                                        "validation/DOC6567_deletions/transcripts/")

transcript_files <- list.files(transcript_folder, full.names = TRUE)

cdkn2ab_df <- transcript_files |> 
  map(\(transcript_files) read_ensembl_exon_table(transcript_files)) |> 
  list_rbind()

cdkn2ab_df_mod <- cdkn2ab_df |> 
  mutate(
    gene = case_when(
      transcript == "ENST00000304494" ~"CDKN2A",
      transcript == "ENST00000579755" ~"CDKN2A",
      transcript == "ENST00000276925" ~"CDKN2B"
    ),
    refseq = case_when(
      transcript == "ENST00000304494" ~"NM_000077.5",
      transcript == "ENST00000579755" ~"NM_058195.4",
      transcript == "ENST00000276925" ~"NM_004936.4"
    ),
    refseq = factor(refseq, levels = c("NM_004936.4",
                                       "NM_058195.4",
                                       "NM_000077.5",
                                       "Gene")),
    exon_char = case_when(
      transcript == "ENST00000304494" & exon == 1 ~"1a",
      transcript == "ENST00000579755" & exon == 1 ~"1b",
      TRUE ~as.character(exon)
    ))

```

```{r}
#| label: fig-cdkn2a-locus
#| fig-cap: "The CDKN2A/B locus"
#| fig-width: 6
#| echo: FALSE

cdkn2a_plot_buffer <- 10000

cdkn2a_plot_start <- 21967752 - cdkn2a_plot_buffer

cdkn2a_plot_end <- 22009305 + cdkn2a_plot_buffer

cdkn2a_targets <- target_df_with_coordinates |> 
  filter(chromosome == "9") |> 
  filter(start > cdkn2a_plot_start &
           end < cdkn2a_plot_end) |> 
  mutate(y_value = "Targets")

cdkn2a_target_plot <- ggplot(cdkn2a_targets, aes(x = start, y = y_value)) +
  geom_point(shape = 21, size = 3) +
  theme_bw() +
  labs (x = "GRCh38 coordinates (chr9)", y = "") +
  scale_x_continuous(limits = c(cdkn2a_plot_start, cdkn2a_plot_end))

cdkn2a_transcripts_plot <- ggplot(cdkn2ab_df_mod, aes(x = start, y = refseq,
                           label = exon_char)) +
  geom_segment(aes(x = start, xend = end,
                   y = refseq, yend = refseq),
               linewidth = 4) +
  # Lines to connect gene exons
  geom_segment(aes(
    x = 21974857, xend = 21967752,
    y = "NM_000077.5", yend = "NM_000077.5")) +
  geom_segment(aes(
    x = 21994392, xend = 21967752,
    y = "NM_058195.4", yend = "NM_058195.4")) +
  geom_segment(aes(
    x = 22002903, xend = 22009305,
    y = "NM_004936.4", yend = "NM_004936.4")) +
  geom_label(nudge_y = 0.4) +
  theme_bw() +
  labs(y = "", x = "") +
  theme(axis.text.x = element_blank()) +
  scale_x_continuous(limits = c(cdkn2a_plot_start, cdkn2a_plot_end)) +
  geom_text(x = 21980000, y = "Gene",
            label = "CDKN2A") +
  geom_text(x = 22005000, y = "Gene",
            label = "CDKN2B") +
  scale_y_discrete(drop = FALSE)

fig_cdkn2a_locus <- (cdkn2a_transcripts_plot / cdkn2a_target_plot) +
  plot_layout(
    heights = c(3, 1)
  )

fig_cdkn2a_locus

```

Due to their proximity, *CDKN2A* and *CDKN2B* are frequently deleted together,
and this co-deletion of these loci may be abbreviated to *CDKN2A/B*. However
there are less common cases where only one gene is deleted. For example, 
@gonzálezgil2021 reported that in 20% of acute lymphoblastic leukaemia only 
one of *CDKN2A* or *CDKN2B* was lost. biallelic *CDKN2A/B* deletion is
included in the fifth edition 
of the World Health Organisation Classification
of Tumours of the Central Nervous System [@louis2021], and is associated with
poor prognosis in multiple types of brain tumour [@sievers2020; @yuile2023].

The size of deletions at the *CDKN2A/B* locus vary. @vieler2023 used optical
genome mapping to characterise *CDKN2A/B* deletions in acute lymphoblastic
leukaemia, showing deletions ranging from 24 kb to 34 Megabases (Mb). 
@hamid2019 analysed *CDKN2A* deletions reported on the COSMIC
database and calculated a median deletion length of 1.2 Mb.
Germline *CDKN2A* mutations increase predisposition to melanoma 
[@toussi2020; @ming2020], 
whilst a single publication links germline mutations in *CDKN2B* to renal cell
carcinoma [@jafri2015]. Germline deletions spanning both *CDKN2A* and
*CDKN2B* have been reported [@jensen2022].

### *PTEN*

The *PTEN* gene is deleted in many different cancer types [@alvarezgarcia2019].
Germline mutations in *PTEN* cause PTEN hamartoma tumor syndrome [@yehia2020],
and germline deletions in PTEN can either encompass the whole gene or 
include only certain exons [@zhou2003]. 

## Detection of gene deletions and ploidy states

Somatic deletions were originally characterised using karyotyping and
fluorescence in-situ hybridisation (FISH). These cytogenetic techniques can
view cancers at a single-cell resolution. Over the last 25 years, there has
been increasing development of molecular methods for detection of somatic CNVs
and ploidy states, beginning with array comparative genome hybridisation
(CGH) and 
single-nucleotide polymorphism (SNP)
microarrays [@das2013; @spence2022], before progressing to 
Illumina short-read
next generation sequencing (NGS) of gene-panels [@conroy2021; @glodzik2023], 
exomes [@zare2017] and genomes [@yi2023; @sosinsky2024]. The majority of NGS 
approaches use a depth-of-coverage approach:
the number of sequencing reads mapping to a locus is used to infer the copy
number of that locus within the sample. This approach was based on initial
array approaches, in which the signal intensity from a probe was used to infer
the locus copy number [@teo2012].

### Challenges

Whilst array and NGS approaches can define genomic losses more precisely than
previous cytogenetic techniques, they do not allow single-cell resolution.
Instead, DNA from millions of cancer and stromal cells is homogenised and
analysed simultaneously within the same experiment. As a result, identifying
somatic CNVs and ploidy states by these methods is confounded by three biological factors:

- **Neoplastic cell content (NCC):** the neoplastic cell content is the 
proportion of tumour cells within a sample. NCC may also be referred to as 
tumour purity or cancer cell fraction. The NCC can vary significantly and this 
impacts the sensitivity  of any copy-number technique. In addition, the normal 
tissue may contain  germline genetic variation which may mask or alter the
signal of somatic variation.

- **Ploidy:** cancer cells frequently deviate from a standard diploid
chromosome complement to become polyploid. Polyploidy arises across many
different cancer types, usually arising after mitotic replication without
cytokinesis, known as endoreplication, which multiplies the genome within a
single cell [@conway2024].

- **Intra-tumoural heterogeneity:** cancers are composed  of diverse
populations of cells, in which copy number changes may only found in specific
sub-clones [@dagogojack2018]. Analysing the homogenised DNA of tumours risks
missing or misinterpreting the contributions from low-level, but
clinically significant, cell populations.

In addition, depth-of-coverage methods for CNV detection are also impacted by
technical variation within samples:

- **GC content:** the GC content of DNA fragments can alter the read count
in short-read NGS in a non-linear fashion, with both high and low GC contents
associated with reduced sequencing depth [@benjamini2012]. Various statistical
methods have been developed to attempt to correct for this bias [@teo2012].

- **Formalin fixation:** the process of fixing tumour samples in formalin
chemically modifies DNA, leading to shorter DNA fragments and non-uniform 
sequencing coverage [@steiert2023]. 

### Approaches

Purity, ploidy and intratumoural heterogeneity create a problem: the analysis 
method must take data from a bulk-sequenced sample and attempt to separate out,
or "deconvolute", 
the underlying genomic complexity [@gao2020; @chandramohan2022]. A pragmatic 
approach is to combine sequence dosage and allele-frequency 
analysis, which was 
first introduced by combining array CGH and SNP-arrays [@zhao2004; @vanloo2010; 
@gardina2008] and has since been adopted for NGS approaches [@carter2012]. These
approaches frequently employ Hidden Markov Models (HMMs): statistical models
which use raw data to select the most likely copy number and ploidy state 
from a series of
possible states [@seiser2014].

NGS analysis can be performed on a tumour sample ("tumour-only") or paired tumour 
and germline samples, with paired analysis having the advantage of being able 
to distinguish between somatic and germline variants [@jones2015]. Other 
approaches which have shown promise for solving the challenges of purity, 
ploidy and heterogeneity deconvolution include multiple tumour sequencing 
[@zaccaria2020] and single-cell genome sequencing [@baslan2020]. However, these 
techniques are expensive and experimental, and consequently have not yet been
clinically implemented. Notably, the WHO guidelines do not specify a technology 
for CNV detection, which reflects the diversity of approaches used in clinical 
laboratories [@neill2020].

## Requirements {#sec-requirements}

The requirements for this new method are as follows:

1. **Results:** the test should provide clear results for the presence of 
whole-gene deletion in the `r length(del_genes)` specified TSGs. The test
should also provide results for the ploidy state, including copy-neutral
LOH, of the following genes:
*MSH2*, *MSH6*, *MLH1*, *PMS2*, *LZTR1*, *SMARCB1* and *NF2*.

2. **Analytical validity:** the test should have a defined sensitivity and 
specificity, calculated by comparison with orthogonal methods.

3. **Dosage accuracy:** it should be shown how accurate the test is at detecting 
monoallelic and biallelic deletions, in samples with a range of NCC values.

4. **Quality control:** the test should have clear quality control thresholds
for deciding when the test results should be reported and when the test has 
failed.

5. **Variability:** the test should have defined variation for detection of 
deletions. Analysis of this variation should then be used to derive the 
uncertainty of measurement for the test.

6. **Visualisation:** the results should be presented in a clear and visual 
manner.

7. **Analysis:** there should be a clear procedure for analysis for gene 
deletions by laboratory staff.

{{< pagebreak >}}

# Methodology

## Samples

```{r}
#| label: samples-tested
#| include: FALSE

cancer_types_tested <- del_val_sample_cancer_types |> 
  filter(labno %in% del_val_collated_stdev$labno &
           # Remove seracare synthetic control
           labno != "24039973") 

samples_tested <- del_val_sample_patient_info |> 
  filter(labno %in% del_val_collated_stdev$labno &
           labno != "24039973") 

```

Tumour samples from NHS cancer patients were tested at the North West GLH
(Manchester site) for this validation.
The majority of DNA samples were extracted from formalin-fixed 
paraffin-embedded (FFPE) tissue using a QIAsymphony instrument (QIAgen) 
([DOC6251]{custom-style="Strong"}). The majority of samples were taken from
brain tumours (@tbl-cancer-types and @tbl-cns-cancer-types).

```{r}
#| label: tbl-cancer-types
#| tbl-cap: "Validation cohort cancer types"
#| echo: FALSE

cancer_types_grouped <- cancer_types_tested |> 
  group_by(cancer_group) |> 
  count()

count_cns <- cancer_types_grouped[cancer_types_grouped$cancer_group == "Central nervous system", 2]

percent_cns <- round((count_cns / sum(cancer_types_grouped$n))* 100, 0)

tbl_cancer_types <- cancer_types_grouped |> 
  arrange(desc(n)) |> 
  rename(`Cancer type` = cancer_group,
         `Samples` = n) |>
  adorn_totals()

kable(tbl_cancer_types)

```

```{r}
#| label: tbl-cns-cancer-types
#| tbl-cap: "Central nervous system tumours"
#| echo: FALSE

tbl_cns_cancer_types <- cancer_types_tested |>
  filter(cancer_group == "Central nervous system") |> 
  group_by(cancer) |> 
  count() |> 
  arrange(desc(n)) |> 
  rename(`Cancer type` = cancer,
         `Samples` = n) |>
  adorn_totals()

kable(tbl_cns_cancer_types)

```

## Next generation sequencing

Samples were processed on the PanSolid version 2 enrichment (CDHS-48608Z-11752)
and sequenced with 2 x 150bp paired-end sequencing on an
Illumina Novaseq
([DOC6278]{custom-style="Strong"})
. The PanSolid panel is a QIAseq enrichment containing primers
for `r nrow(target_df)` genomic targets. 
`r nrow(target_df[target_df$target_type == "gene target",])` targets lie within
specific genes related to cancer, and a further 
 `r nrow(target_df[target_df$target_type == "genomic backbone",])`
targets provide a genomic backbone for ploidy state prediction. Samples were
tested on `r length(unique(del_val_pansolid_worksheet_details$pcrid))` 
worksheets between 
`r format.Date(x = min(del_val_pansolid_worksheet_details$date), format = "%B %Y")`
and
`r format.Date(x = max(del_val_pansolid_worksheet_details$date), format = "%B %Y")`.

## PanSolid CLC bioinformatics pipeline

A bioinformatics pipeline was built in the CLC Genomics Workbench v23 (Qiagen).
The details of the pipeline are described in 
[DOC6260]{custom-style="Strong"} and [DOC6283]{custom-style="Strong"}.
The graining level for
each gene was set based on the number of targets present 
within the gene (@tbl-deletion-gene-targets). 
The 
version of the PanSolid CLC pipeline tested in this validation was PanSolid 
Workflow v2.4. Broadly speaking, the pipeline includes two different 
components for detection of copy number and ploidy: the CNV Detection tool and
the Detect Regional Ploidy tool (@fig-clc-pipeline).

```{r}
#| label: clc-pipline-diagram
#| include: FALSE

path_clc_pipeline <- paste0(image_folderpath,
                            "clc_pipeline.png")

```

![CLC pipeline](`r path_clc_pipeline`){#fig-clc-pipeline width=5in}

### Gene lists and graining levels

Deletions were detected in `r length(del_genes)` genes with the graining levels
specified in @gene_target_counts (Appendix). Detection of amplifications 
was performed for the 9 genes specified in 
[DOC6283]{custom-style="Strong"} plus an additional four genes: *CDK12*, 
*FGFR1*, *FGFR2* and *FGFR3*. Amplification detection for these four genes was
added to the NHS Genomic Medicine Test Directory since the validation of
amplification detection on the PanSolid pipeline. *CDK12* has both 
tumour-suppressor and oncogenic effects on cancer development
[@paculova2017] and was analysed for both amplifications and deletions.

### Deletion detection by fold change {#sec-methods-fold-change}

The PanSolid CLC pipeline calculates the "fold change" of a copy number region in
comparison the results from a cohort of 25 normal controls (described in 
[DOC6260]{custom-style="Strong"}).
Two separate equations are used for calculating the fold change of copy number
gains ([@eq-fold-change-gain]) and copy number losses ([@eq-fold-change-loss]).

$$
FCgain = CNsample / CNnormal
$$ {#eq-fold-change-gain}

$$
FCloss = - (CNnormal / CNsample)
$$ {#eq-fold-change-loss}

```{r}
#| label: fold-change
#| include: FALSE

fold_change_df <- data.frame(ncc = seq(0, 100, by = 0.1)) |> 
  mutate(fold_change_normal = pred_fc(tumour_cpc = 2,
                                      ncc = ncc,
                                      dir = "loss",
                                      digits = 3),
         fold_change_het_del = pred_fc(tumour_cpc = 1,
                                       ncc = ncc,
                                       dir = "loss",
                                       digits = 3),
         fold_change_hom_del = pred_fc(tumour_cpc = 0,
                                       ncc = ncc,
                                       dir = "loss",
                                       digits = 3)) |> 
  pivot_longer(cols = -ncc,
               names_to = "del_state",
               values_to = "fold_change")


```

The NCC of a sample and the number of gene copies per cell both impact the total
measured fold change and copy number of a sample, with fold change providing a 
greater distinction between biallelic and monoallelic deletions, as shown in 
@fig-fold-change-vs-ncc and @fig-fold-change-vs-cn. 
Initially, the fold change threshold 
was set at
`r round(deletion_fc_threshold_theoretical,2)`
as this was the predicted fold change for a sample with a monoallelic deletion 
at 50% NCC. Following initial testing of samples, this was modified to
`r deletion_fc_threshold`.

```{r}
#| label: fig-fold-change-vs-ncc
#| fig-cap: "Fold change vs neoplastic cell content"
#| echo: FALSE

fig_fold_change_vs_ncc <- ggplot(fold_change_df, aes(x = ncc, y = fold_change)) +
  geom_line(aes(colour = del_state), linewidth = 1) +
  scale_colour_manual(values = c( "#999999", "#999999", "#999999")) +
  coord_cartesian(ylim = c(-5, 0)) +
  scale_y_continuous(breaks = c(0, -1, round(deletion_fc_threshold, 2),
                                -2, -3, -4, -5),
                     minor_breaks = NULL) +
  scale_x_continuous(breaks = seq(0, 100, by = 10)) +
  theme_bw() +
  theme(legend.position = "blank") +
  labs(y = "Fold change (loss equation)", x = "Neoplastic cell content",
       colour = "") +
  geom_hline(yintercept = round(deletion_fc_threshold,2), linetype = "dashed") +
  annotate("text", x = 65, y = -4.5, label = "Biallelic \n deletion") +
  annotate("text", x = 90, y = -2.5, label = "Monoallelic \n deletion") +
  annotate("text", x = 90, y = -0.5, label = "Normal")

fig_fold_change_vs_ncc

```

```{r}
#| label: fig-fold-change-vs-cn
#| fig-cap: "Fold change vs copy number"
#| echo: FALSE

copy_number_df <- data.frame(ncc = seq(0, 100, by = 1)) |> 
  # Imagine for 100 cells
  mutate(copy_number_norm = 2,
         copy_number_het_del = ((ncc*1) + ((100-ncc)*2)) / 100,
         copy_number_hom_del = ((ncc*0) + ((100-ncc)*2)) / 100) |> 
  pivot_longer(cols = -ncc,
               names_to = "del_state",
               values_to = "copy_number")

fig_fold_change_vs_cn <- ggplot(copy_number_df, aes(x = ncc, y = copy_number)) +
  geom_line(aes(colour = del_state), linewidth = 1) +
  scale_colour_manual(values = c( "#999999", "#999999", "#999999")) +
  scale_x_continuous(breaks = seq(0, 100, by = 10)) +
  theme_bw() +
  theme(legend.position = "blank") +
  labs(y = "Overall copy number", x = "Neoplastic cell content",
       colour = "") +
  annotate("text", x = 75, y = 0.2, label = "Biallelic \n deletion") +
  annotate("text", x = 90, y = 0.8, label = "Monoallelic \n deletion") +
  annotate("text", x = 90, y = 1.8, label = "Normal") 

fig_fold_change_vs_cn

```

### Ploidy state detection

Ploidy status of copy number segments was predicted using the CLC
"Detect Regional Ploidy" tool with the "Region-level Ploidy Track". This uses
a HMM to predict ploidy based on SNP and coverage data, which 
is influenced by @beroukhim2006. The different ploidy states categorised by the
ploidy caller are summarised in @tbl-clc-ploidy-states. 

### Visualisation

A new visualisation of the pipeline results was developed to include deletions 
and ploidy predictions (@fig-24021613-visualisation). In the interactive HTML
file (@fig-24021613-visualisation section C) the predictions of the Detect
Regional Ploidy tool were used to colour the target log2 ratios. A visualisation
of allele frequency was also added, displaying 
the read depth percentages of variants filtered by the following criteria:

1) The variant was in a Genome In A Bottle high-confidence region
2) The variant had a frequency greater than 4%

```{r}
#| label: visualisation-image
#| include: FALSE

path_24021613 <- paste0(image_folderpath,
                        "24021613_visualisation.png")

caption_24021613 <- "The new visualisation for the results of the PanSolid
CLC pipeline (sample 24021613, WS146523, panel v2PANSOLID)."

```

![`r caption_24021613`](`r path_24021613`){#fig-24021613-visualisation height=7in}

{{< pagebreak >}}

### Quality control

The signal-adjusted noise quality control metric was developed during 
the *ERBB2* amplification validation and is described in detail in 
[DOC6260]{custom-style="Strong"}. In addition,
the percentage of the panel BED targets covered at 138X or higher was used as
a further quality metric. A threshold of 75% was set for this metric following
*in silico* downsampling experiments performed for 
[INC9967]{custom-style="Strong"}.

## Orthogonal testing

### Whole genome sequencing

Whole genome sequencing (WGS) was performed by Illumina Laboratory 
Services in Cambridge as part of the NHS Genomic
Medicine Service [@sosinsky2024]
on paired blood and fresh frozen tumour samples. The fresh frozen samples were
taken from tumours with matching pathology identifiers to the FFPE samples 
tested on PanSolid. Genomics England requires solid tumour samples to 
NCC values of at least 30% with less than 20% cell necrosis.
Bioinformatic analysis was
performed by Genomics England, and HTML reports were downloaded from the 
Genomics
England [clinical interpretation portal](https://cipapi.genomicsengland.nhs.uk/interpretationportal/gms/). The
samples included in this validation are comprised of those previously tested as
part of the validation of amplification detection 
[DOC6283]{custom-style="Strong"}, plus additional samples with specific gene
deletions detected on WGS.
Within the Genomics England WGS pipeline, tumour ploidy and chromosome 
count were calculated by the Canvas algorithm [@roller2016].  Whilst Canvas predicts tumour purity, the tumour purity stated on the 
final HTML report is predicted using the Ccube package [@yuan2018]. 

### Droplet digital PCR

Droplet digital PCR (ddPCR) assays were designed for the *CDKN2A* and 
*PTEN* genes. ddPCR was performed on a BioRad QX200 system at the North West
GLH with 20ng DNA input per well.
The ddPCR
assays were validated on WS146103 and samples were tested on WS146462 and 
WS146463.
The same ddPCR mix volumes and thermocycling conditions were used as for the 
previous validations of amplification detection, and are detailed in 
the Supplementary 
Information of [DOC6283]{custom-style="Strong"}.

### PCR loss of heterozgosity testing: *NF2*

```{r}
#| label: nf2-markers
#| include: FALSE

nf2_loh_markers <- tribble(
  ~marker,      ~chromosome, ~grch38_start,    ~grch38_end,
  "D22S275",    "22",        28718848,         28719015,
  "NF2CA3",     "22",        29628082,         29628219,
  "NF2intron10", "22",       29670415,         29670600,
  "D22S268",     "22",       30162212,         30162464
) |> 
  mutate(grch38_coord = str_c(grch38_start, "-", grch38_end),
         amplicon_size_bp = abs(grch38_start - grch38_end))

nf2_marker_mb <- round((max(nf2_loh_markers$grch38_end) - 
                          min(nf2_loh_markers$grch38_start)) / 10^6, 1)

nf2_loh_targets <- target_df_with_coordinates |> 
  filter(chromosome == "22") |> 
  filter(start >= min(nf2_loh_markers$grch38_start) &
           end <= max(nf2_loh_markers$grch38_end))

```

DNA samples with results from PCR microsatellite testing of *NF2* were used to
validate the ability of the CLC Detect Regional Ploidy tool to detect regions of 
copy-loss and copy-neutral LOH. At 
the North West GLH, LOH testing for *NF2* is performed by targeting 4 dinucleotide 
microsatellite repeat markers (D22S275, NF2CA3, NF2intron10 and
D22S268) spanning `r nf2_marker_mb` Mb of chromosome 22 (@tbl-nf2-markers).
The fluorescence-labelled PCR 
products for paired
DNA samples from tumour and blood are analysed on an ABI-3130 analyser 
([LP 000 069: Neurofibromatosis type 2 (NF2): Standard Operating
Procedure]{custom-style="Strong"}). A relative loss of peak height greater than 
30% between tumour DNA and blood DNA is used to classify 
"significant LOH" [@wallace2004]. Results for the NF2 LOH PCR assays were 
extracted from the DNA Database.

```{r}
#| label: tbl-nf2-markers
#| tbl-cap: "NF2 LOH dinucleotide markers"
#| echo: FALSE

kable(nf2_loh_markers |> 
        select(-c(grch38_start, grch38_end)) |> 
        rename(`Marker` = marker,
               `Chromosome` = chromosome,
               `Coordinates (GRCh38)` = grch38_coord,
               `Amplicon (bp)` = amplicon_size_bp))

```

### NGS loss of heterozygosity testing: *MLH1*, *MSH2* and *MSH6*

4 samples previously tested on the "Merged" QIAseq panel for LOH in the  
*MLH1*, *MSH2* and *MSH6* genes were tested using the PanSolid enrichment on 
WS150529.

## Validation analysis

All data analysis was performed in R version 4.4.1 [@rcore2024] using 
multiple packages 
including the tidyverse [@wickham2019]. Sensitivity and specificity metrics
were calculated using the epiR package [@stevenson2008] and fold change
conversions performed using the foldchanger package [@shaw2024].
This validation document is written and
rendered with Quarto [@allaire2024].
All analysis scripts are saved in a public Github repository:
[https://github.com/joe-m-shaw/pansolid_cnv_validation/tree/main/vignettes](https://github.com/joe-m-shaw/pansolid_cnv_validation/tree/main/vignettes)

All data analysed in this validation is saved at this file location:

Genetics/Mol_Shared/Development.Team/PanSolid CNV/data/validation/DOC6567_deletions

{{< pagebreak >}}

# Results

## CNV caller results

```{r}
#| label: overall-results
#| include: FALSE

noise_138x_ncc <- del_val_collated_stdev |> 
  left_join(del_val_collated_138x |> 
               select(filepath, percent_138x),
             by = "filepath",
            relationship = "one-to-one") |> 
  inner_join(del_val_collated_pred_ncc |> 
               select(filepath, pred_ncc),
              by = "filepath",
            relationship = "one-to-one")

stopifnot(anyNA.data.frame(noise_138x_ncc |> 
                   select(-suffix)) == FALSE)

results_passing_qc <- noise_138x_ncc |> 
  filter(stdev_noise <= noise_qc_threshold &
           percent_138x >= percent_138x_qc_threshold)

sig_cnvs_with_qc <- del_val_collated_sig_cnvs |> 
  left_join(noise_138x_ncc |> 
              select(filepath, stdev_noise, percent_138x, pred_ncc),
            by = "filepath",
            relationship = "many-to-one") |> 
  left_join(del_val_sample_cancer_types, by = "labno")

sig_cnvs_passing_qc <- sig_cnvs_with_qc |> 
  filter(stdev_noise <= noise_qc_threshold &
           percent_138x >= percent_138x_qc_threshold &
           consequence == "Loss")
           
del_gene_results_with_ids <- del_val_collated_del_genes |> 
  left_join(del_val_sample_patient_info, by = "labno",
            relationship = "many-to-one") |> 
  left_join(noise_138x_ncc |> 
              select(filepath, stdev_noise, percent_138x, pred_ncc),
            by = "filepath",
            relationship = "many-to-one") |> 
  left_join(del_val_sample_cancer_types,
            by = "labno",
            relationship = "many-to-one")

del_gene_cnv_spans <- del_gene_results_with_ids |> 
  filter(stdev_noise <= noise_qc_threshold &
           percent_138x >= percent_138x_qc_threshold) |> 
  mutate(cnv_span = case_when(
    min_region_fold_change == max_region_fold_change ~"Spans whole gene",
    min_region_fold_change != max_region_fold_change ~"Intragenic"
  ))

intragenic_region_changes <- nrow(del_gene_cnv_spans[del_gene_cnv_spans$cnv_span == "Intragenic", ])

intragenic_region_percent <- round((intragenic_region_changes / nrow(del_gene_cnv_spans))*100, 1)

```

```{r}
#| label: calls-per-case
#| include: FALSE

sig_cnvs_with_qc_mod <- sig_cnvs_with_qc |> 
  mutate(pass_qc  = case_when(
           stdev_noise <= noise_qc_threshold &
             percent_138x >= percent_138x_qc_threshold ~"Yes",
           stdev_noise > noise_qc_threshold |
             percent_138x < percent_138x_qc_threshold ~"No"),
         pass_qc_factor = factor(pass_qc, levels = c("Yes", "No"))) 

loss_count_df <- sig_cnvs_with_qc_mod |> 
  filter(consequence != "Gain") |> 
  group_by(labno_suffix_worksheet, labno, stdev_noise, percent_138x,
           pass_qc_factor,
           consequence) |> 
  count(.drop = FALSE) |>  
  mutate(calls = case_when(
    consequence == "no call" & n == 1 ~0,
    TRUE ~n
  ))

loss_count_df_qc <- loss_count_df |> 
  filter(pass_qc_factor == "Yes")

stopifnot(length(setdiff(loss_count_df_qc$labno_suffix_worksheet,
        results_passing_qc$labno_suffix_worksheet)) == 0)

calls_with_cancer <- loss_count_df_qc |> 
  left_join(del_val_sample_cancer_types,
            by = "labno")

calls_by_cancer <- calls_with_cancer |> 
  group_by(cancer, cancer_group) |> 
  summarise(mean = mean(calls),
            samples = n()) 

over_5 <- calls_by_cancer |> 
  filter(samples > 5)

plot_calls_by_cancer_type <- calls_with_cancer |> 
  filter(cancer %in% over_5$cancer) |> 
  ggplot(aes(x = reorder(cancer, calls),
                              y = calls)) +
  geom_boxplot() +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1,
                                   hjust = 1)) +
  labs(x = "", y = "Significant CNVs",
       title = "Number of detected CNVs varies with cancer type",
       subtitle = "Data shown for cancer types with more than 5 samples in cohort")

```

```{r}
#| label: manual-call-review
#| include: FALSE

sig_cnvs_with_manual_review <- sig_cnvs_with_qc_mod |> 
  filter(consequence == "Loss" &
           analyst_result %in% c("deletion", "no deletion")) 

manual_review_false_pos <- sig_cnvs_with_manual_review |> 
  filter(analyst_result == "no deletion")

sig_cnvs_with_qc_mod_pval_cat <- sig_cnvs_with_manual_review |> 
  mutate(p_value_category  = case_when(
    p_value == 0 ~"0",
    p_value > 0 ~"Above 0"
  ),
  analyst_result = case_when(
    analyst_result == "no deletion" ~"manual review: no deletion",
    analyst_result == "deletion" ~"manual review: deletion"
  )) 

pvalue_plot <- sig_cnvs_with_qc_mod_pval_cat |> 
  ggplot(aes(x = p_value_category, y = )) +
  geom_bar() +
  facet_wrap(~analyst_result) +
  theme_bw() +
  labs(x = "P value", y = "Number of CNVs")

```

In total, `r nrow(noise_138x_ncc)` replicates from 
`r length(unique(noise_138x_ncc$labno))` DNA samples were tested on the PanSolid
enrichment and analysed with the PanSolid CLC pipeline.
Of these, `r nrow(results_passing_qc)` replicates had signal-adjusted noise 
values below 0.7 and percentage coverage at 138X greater than 75%.
There was a clear relationship between the size of the detected deletions and
their fold changes (@fig-cnv-size-distribution); shorter focal deletions had
lower fold change values, consistent with biallelic losses, and all regions with 
 fold changes below -3 were less than 7 Megabases (Mb) in length.

`r nrow(sig_cnvs_passing_qc)` target gene regions with fold changes lower than the 
`r deletion_fc_threshold` threshold were detected. 
Deletions were detected in all 
`r length(unique(del_val_collated_del_genes$gene))` target genes 
(@fig-cnv-gene-frequency), with fold changes 
ranging from 
`r max(sig_cnvs_passing_qc$fold_change)` to
`r min(sig_cnvs_passing_qc$fold_change)`, and CNV lengths ranging from
`r round(min(sig_cnvs_passing_qc$cnv_length)/1000,1)` kb to 
`r round(max(sig_cnvs_passing_qc$cnv_length)/1000000,1)` Mb 
In `r intragenic_region_changes` (`r intragenic_region_percent`%) results, 
there was more than one fold change region detected within a gene. In the results
passing the quality thresholds, the number of detected deletion regions per
case ranged from
`r min(loss_count_df_qc$calls)` to 
`r max(loss_count_df_qc$calls)` (median
`r median(loss_count_df_qc$calls)`
). The three 
genes with the most detected deletions were *PTEN*, *CDKN2A* and *PTEN*. This was
likely due to ascertainment bias as these deletions are commonly detected in
brain tumours, which comprised
`r percent_cns`% of the samples tested (@tbl-cancer-types).

Of the 
`r nrow(sig_cnvs_with_manual_review)`
significant CNVs called, 
`r nrow(manual_review_false_pos)`
were categorised as not being deletions on
manual review. The p values of the CNV calls ranged from
`r min(sig_cnvs_with_manual_review$p_value)` to
`r max(round(sig_cnvs_with_manual_review$p_value, 3))`, and CNVs with p values
above 0 were more likely to be classified as not being deletions on manual
review. CNVs with p values above 0.05 were not considered significant CNVs.

```{r}
#| label: fig-cnv-size-distribution
#| fig-cap: "Deletion results for all genes"
#| echo: FALSE

fig_cnv_size_distribution <- sig_cnvs_passing_qc |> 
  mutate(cnv_length_mb = cnv_length / 1000000) |> 
  ggplot(aes(x = cnv_length_mb,
             y = fold_change)) +
  geom_point(shape = 21) +
  theme_bw() +
  scale_x_continuous(limits = c(0, 140),
                     breaks = seq(0, 140, by = 10)) +
  scale_y_continuous(limits = c(-30, 0),
                     breaks = c(0, -10, -20, -30)) +
  labs(x = "CNV length (Megabases)", y = "Fold change (loss)",
       title = "Deletion results for all genes",
       subtitle = "Data from results passing quality control thresholds")

fig_cnv_size_distribution

```

```{r}
#| label: fig-cnv-gene-frequency
#| echo: FALSE

fig_cnv_gene_frequency <- sig_cnvs_passing_qc |> 
  group_by(gene, consequence) |> 
  count() |> 
  arrange(desc(n)) |>  
  ggplot(aes(x = reorder(gene, desc(n)), 
             y = n)) +
  geom_col() +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(x = "", y = "Number of deletions",
       title = "Frequencies of deletions in target genes",
       subtitle = "Data from results passing quality control thresholds")

fig_cnv_gene_frequency

```

### *CDKN2A* and *PTEN* results

The deletions detected at the *CKDN2A/B* locus on chromosome 9p are shown in
@fig-cdkn2a-results, and the *PTEN* deletions detected on chromosome 10 are
shown in @fig-pten-results. The majority of CNVs included both the *CDKN2A* and
*CDKN2B* genes.

24026819: CDKN2A only deletion (not with CDKN2B)

```{r}
#| label: fig-cdkn2a-results
#| echo: FALSE
#| fig-width: 6
#| fig-height: 9

cdkn2a_pass_qc <- sig_cnvs_passing_qc |> 
  filter(gene %in% c("CDKN2A", "CDKN2B")) |> 
  arrange(desc(start)) |> 
  mutate(labno_start = str_c(labno, "_", no_targets))

cdkn2a_pass_qc_factors <- cdkn2a_pass_qc |> 
  mutate(labno_factor = factor(labno, levels = unique(labno)))

NM_000077_start <- 21967752

NM_000077_end <- 21974857

NM_058195_end <- 21994392

NM_004396_start <- 22009305

NM_004396_end <- 22002903

cdkn2a_labno_plot <- ggplot(cdkn2a_pass_qc_factors, 
                            aes(x = start,
                                y = labno_factor,
                                colour = fold_change)) +
    theme_bw() +
    theme(axis.text.x = element_blank()) +
    geom_segment(aes(x = start, xend = end, 
                     y = labno_factor, yend = labno_factor),
                 linewidth = 2) +
    scale_colour_gradient(high = "#FF9999", 
                          low = "#660000", 
                          limits = c(min(cdkn2a_pass_qc_factors$fold_change),
                                     max(cdkn2a_pass_qc_factors$fold_change)),
                          n.breaks = 4) +
    labs(
      y = "Sample",
      x = "",
      colour = "Fold change") +
  coord_cartesian(xlim = c(cdkn2a_plot_start, cdkn2a_plot_end)) +
  geom_vline(xintercept = NM_000077_start, linetype = "dashed") +
  geom_vline(xintercept = NM_000077_end, linetype = "dashed") +
  geom_vline(xintercept = NM_058195_end, linetype = "dashed") +
  geom_vline(xintercept = NM_004396_start, linetype = "dashed") +
  geom_vline(xintercept = NM_004396_end, linetype = "dashed")


(cdkn2a_labno_plot / cdkn2a_transcripts_plot / cdkn2a_target_plot) +
    plot_layout(
      heights = c(10, 3, 1)
    )

```

```{r}
#| label: fig-pten-results
#| echo: FALSE
#| fig-width: 6
#| fig-height: 9

pten_pass_qc <- sig_cnvs_passing_qc |> 
  filter(gene == "PTEN") |> 
  arrange(desc(start), labno) 

pten_pass_qc_factors <- pten_pass_qc |> 
  mutate(labno_factor = factor(labno, levels = unique(labno)))

pten_buffer <- 40000

pten_labno_plot <- make_labno_cnv_plot(df = pten_pass_qc_factors,
                                         yaxis = labno_factor,
                    gene = "PTEN", interval = 10000)

pten_zoom <- pten_labno_plot[[4]] +
  coord_cartesian(xlim = c(87863625-pten_buffer, 87971930+pten_buffer))

pten_exon_plot <- make_exon_plot(plot_xmin = 87863625-pten_buffer,
                                   plot_xmax = 87971930+pten_buffer,
                                   chromosome = "10",
                                   interval = 10000)

pten_primer_plot <- make_primer_plot(plot_xmin = 87863625-pten_buffer,
                                   plot_xmax = 87971930+pten_buffer,
                                   chromosome = "10",
                                   interval = 10000)

(pten_zoom / pten_primer_plot / pten_exon_plot) +
    plot_layout(
      heights = c(10, 1, 2)
    )

```

## Ploidy caller results

```{r}
#| label: tidy-ploidy-data
#| include: FALSE

del_val_collated_loh_mod <- del_val_collated_loh |> 
  left_join(noise_138x_ncc |> 
              select(filepath, stdev_noise, percent_138x, pred_ncc),
            by = "filepath",
            relationship = "many-to-one") |> 
  # Remove samples where DNA was deliberately mixed
  filter(!labno_suffix %in% c("24026628b", "24026628c", "24026628d")) |> 
  filter(stdev_noise <= noise_qc_threshold &
           percent_138x >= percent_138x_qc_threshold) |> 
  # Fix LOH status instances to allow unnest later
  mutate(
    ploidy_states_count  = str_count(string = ploidy_state, ",\\s") + 1,
    loh_status_fixed = case_when(
    (labno_suffix_worksheet == "24038351_WS143668" & gene == "PMS2") ~"No, Yes, Yes",
    labno_suffix_worksheet == "24027774a_WS144291" & gene == "PMS2" ~"No, Yes, No",
    labno_suffix_worksheet == "24022883_WS141364" & gene == "PMS2" ~"No, No",
    TRUE ~loh_status),
    
    ploidy_state_split = strsplit(ploidy_state, split = ",\\s"),
         loh_status_split = strsplit(loh_status_fixed, split = ",\\s"),
         no_targets_split = strsplit(no_targets_in_ploidy_region, 
                                     split = ",\\s")) 

multiple_loh_calls <- del_val_collated_loh_mod |> 
  filter(ploidy_states_count > 1)

del_val_collated_loh_split <- del_val_collated_loh_mod |> 
  unnest(cols = c(ploidy_state_split, loh_status_split, no_targets_split)) |> 
  mutate(no_targets_split = as.numeric(no_targets_split),
         ploidy_state_factor = factor(ploidy_state_split, 
                          levels = c(
                            "(1,3)", "(2,3)", 
                            "(0,3)", "(0,4)", "(2,4)", 
                            "Whole genome duplication",
                            "Duplication",
                            "Bi-allelic deletion",
                             "Deletion",
                            "Uniparental disomy",
                            "Normal diploid")))

```

Ploidy state regions impacting the  `r length(loh_genes)` target genes ranged from 
`r min(del_val_collated_loh_split$no_targets_split)`-
`r max(del_val_collated_loh_split$no_targets_split)` targets in length (median
`r median(del_val_collated_loh_split$no_targets_split)`). 
In 
`r nrow(multiple_loh_calls)` out of 
`r nrow(del_val_collated_loh_mod)` 
results 
(`r round(nrow(multiple_loh_calls) / nrow(del_val_collated_loh_mod)*100, 1)`%)
there were multiple ploidy
states predicted within the same gene. @fig-ploidy-caller-results shows the
frequency of different ploidy state predictions across the 6 genes. Notably,
a similar pattern of ploidy state frequencies is seen for *LZTR1*, *SMARCB1* and
*NF2* as these genes are located closer to each other on chromosome 22q.

```{r}
#| label: fig-ploidy-caller-results
#| fig-cap: "Ploidy caller results. Catergories with numbers in brackets show
#| the predicted copy number of each allele. For example, (2,4) indicates 2
#| copies of the first allele and 4 copies of the second."
#| fig-width: 6
#| fig-height: 5
#| echo: FALSE

fig_ploidy_caller_results <- del_val_collated_loh_split |> 
  mutate(gene_factor = factor(gene, levels = c(
    "MLH1", "MSH2", "MSH6", "PMS2", "LZTR1", "SMARCB1", "NF2"))) |> 
  group_by(gene_factor, loh_status_split, ploidy_state_factor) |> 
  count() |> 
  ggplot(aes(x = n, y = ploidy_state_factor,
             fill = loh_status_split)) +
  geom_col(colour = "black") +
  scale_fill_manual(values = c("white", "red")) +
  theme_bw() +
  theme(legend.position = "bottom") +
  facet_wrap(~gene_factor, nrow = 2) +
  labs(x = "Number of results", y = "", 
       fill = "LOH status",
       title = "Detect Regional Ploidy tool results",
       subtitle = "Data from results passing quality thresholds")

fig_ploidy_caller_results

```

### Disagreements with CNV caller

```{r}
#| label: ploidy-cnv-disagreements
#| include: FALSE

cnv_vs_ploidy_caller <- del_val_collated_del_genes |> 
  inner_join(del_val_collated_loh |> 
               select(filepath, chrom, gene, ploidy_state,
                      loh_status, no_targets_in_ploidy_region,
                      check_1, analyst_result, analyst_comment),
             join_by(filepath, gene)) |> 
  filter(labno_suffix_worksheet %in% 
           results_passing_qc$labno_suffix_worksheet) |> 
  filter(!labno %in% c(
    # sample with small deletion and LOH
    "24035816",
    # Small MSH2 deletion
    "24067827", 
    "25001806"))
  
cnv_ploidy_caller_disagreements <- cnv_vs_ploidy_caller |> 
  filter((pansolid_result == "deletion" &
           !ploidy_state %in% c("Deletion", "Bi-allelic deletion")) |
           (pansolid_result == "no deletion" &
           ploidy_state %in% c("Deletion", "Bi-allelic deletion"))) |> 
  left_join(noise_138x_ncc |> 
              select(filepath, stdev_noise, percent_138x, pred_ncc),
            by = "filepath")

```

In `r nrow(cnv_vs_ploidy_caller)` results for the `r length(loh_genes)` LOH 
genes, there were 
`r nrow(cnv_ploidy_caller_disagreements)` 
(`r round((nrow(cnv_ploidy_caller_disagreements) / nrow(cnv_vs_ploidy_caller))*100, 1)`%)
instances for the 
where the results of the ploidy caller
contradicted the results of the CNV caller.

```{r}
#| label: tbl-ploidy-cnv-disagreements
#| include: FALSE

tbl_ploidy_cnv_disagreements <- cnv_ploidy_caller_disagreements |> 
  select(worksheet, labno, stdev_noise, percent_138x, pred_ncc,
gene, min_region_fold_change, pansolid_result,
ploidy_state, loh_status, analyst_result)

```

{{< pagebreak >}}

## Comparison to whole genome sequencing

```{r}
#| label: chrom-gene-tbl
#| include: FALSE

chrom_gene_tbl <- del_val_wgs_html_cnvs |> 
  filter(gene %in% del_val_collated_del_genes$gene) |> 
  select(chromosome, gene) |> 
  distinct() |> 
  mutate(chrom_num = parse_number(chromosome)) |> 
  arrange(chrom_num)

```

```{r}
#| label: join-pansolid-and-wgs-results
#| include: FALSE

wgs_cnvs_with_ids <- del_val_wgs_html_cnvs |> 
  left_join(del_val_wgs_html_ids,
            by = "filepath",
            relationship = "many-to-one")

patients_with_qiasymphony_extractions <- del_val_sample_patient_info |> 
  # Remove samples with contamination
  filter(!labno %in% c("24030962", "24030945")) |> 
  filter(extraction_method == "QIAsymphony")

pansolid_results_for_wgs_comparison <- del_gene_results_with_ids |> 
  filter(stdev_noise <= noise_qc_threshold &
           percent_138x >= percent_138x_qc_threshold) |> 
  filter(nhsno %in% del_val_wgs_html_ids$nhsno) |> 
  filter(
    (nhsno %in% patients_with_qiasymphony_extractions$nhsno &
    extraction_method == "QIAsymphony") |
      (!nhsno %in% patients_with_qiasymphony_extractions$nhsno)) |> 
  filter(!labno %in% c(
    "23025733",                # Remove sample on Cobas extraction
    "24030945",                # Evidence of DNA contamination
    "24030962",                # Evidence of DNA contamination
    "24018922",                # This sample is from a different path block
    "24033015"                 # Also from a different path block - see note
    )) |>                      # on iGene
  # This sample was repeated for repeatability
  filter((labno != "24017319" & worksheet != "WS144364")) |> 
  # These sample replicates were used for the limit of detection study
  filter((labno != "24053299" & worksheet != "WS150529")) |> 
  filter(!labno_suffix %in% c("24026628a", "24026628b", "24026628c",
                              "24026628d"))
  
pansolid_patients_for_wgs_comparison <- pansolid_results_for_wgs_comparison |> 
  distinct(nhsno, firstname, surname, labno)

stopifnot(anyDuplicated(pansolid_patients_for_wgs_comparison$nhsno) == 0)

pansolid_samples_for_wgs_comparison <- pansolid_results_for_wgs_comparison |> 
  distinct(firstname, surname, labno, worksheet, extraction_method)

stopifnot(anyDuplicated(pansolid_samples_for_wgs_comparison$labno) == 0)

wgs_results_for_pansolid_comparison <- wgs_cnvs_with_ids |> 
  mutate(labno_gene = str_c(labno, "_", gene),
         wgs_cnv_length = abs(cnv_end-cnv_start)) |> 
  # Restrict to one result per gene per labno
  filter(!duplicated(labno_gene))

pansolid_vs_wgs <- pansolid_results_for_wgs_comparison |> 
  left_join(wgs_results_for_pansolid_comparison,
            join_by(nhsno == nhsno, gene == gene),
            relationship = "one-to-one") |> 
  left_join(chrom_gene_tbl |> 
              select(gene, chrom_num), by = "gene")

wgs_cnvs_in_target_genes <- wgs_results_for_pansolid_comparison |> 
  filter(gene %in% unique(del_val_collated_del_genes$gene) &
           cnv_class %in% c("DEL", "LOSS"))

```

The deletion results for `r length(unique(pansolid_vs_wgs$gene))` genes 
on `r length(unique(chrom_gene_tbl$chrom_num))` autosomes were
compared between the PanSolid CLC pipeline and the Genomics England WGS 
pipeline for 
`r length(unique(pansolid_vs_wgs$labno.x))` DNA replicates from
`r length(unique(pansolid_vs_wgs$nhsno))` patients. Deletion calls from the 
Canvas tool, notated as "LOSS" or "LOH" in the WGS results output, were 
compared with the deletion calls from the PanSolid pipeline. No deletion 
structural variants were detected by the Manta algorithm, notated as
"DEL" in the WGS results output, in the target genes. The deleted regions 
detected by Canvas ranged from 
`r round(min(wgs_cnvs_in_target_genes$wgs_cnv_length)/1000, 1)` kb to
`r round(max(wgs_cnvs_in_target_genes$wgs_cnv_length)/1000000, 1)` Mb in
length. To avoid double-counting,
samples where DNA was tested following multiple extraction methods 
(QIAsymphony, Cobas or fresh frozen tissue),
a single sample of DNA extracted via the QIAsymphony method was
selected for the comparison. If QIAsymphony-extracted DNA was not available, 
DNA from fresh frozen tissue was used instead (@tbl-wgs-comparison-summary). 
Results were only compared when
the noise and coverage metrics were above the quality control thresholds. The
CNV regions detected by the PanSolid pipeline were manually reviewed using the
output Excel spreadsheet and the interactive HTML file to check whether each 
CNV region appeared to be genuine. This process revealed examples of both 
false positive and false negative CNV classifications.

```{r}
#| label: compare-pansolid-to-wgs-results
#| include: FALSE

sig_cnvs_for_join <- del_val_collated_sig_cnvs |> 
  filter(!is.na(check_1)) |> 
  distinct(labno_suffix_worksheet, gene, .keep_all = TRUE) |> 
  select(labno_suffix_worksheet, gene, 
         cnv_co_ordinates, cnv_length, consequence,
         fold_change, p_value, no_targets,
         check_1, analyst_result, 
         analyst_comment)

pansolid_vs_wgs_outcomes <- pansolid_vs_wgs |> 
  left_join(sig_cnvs_for_join, 
            join_by(labno_suffix_worksheet, gene)) |> 
  mutate(pansolid_result_combined = case_when(
    
    is.na(analyst_result) ~pansolid_result,
    !is.na(analyst_result) ~analyst_result),
    
    wgs_result = case_when(
      cnv_class %in% c("DEL", "LOSS") ~"Deletion detected",
      !cnv_class %in% c("DEL", "LOSS") |
        is.na(cnv_class) ~"No deletion detected"),

    # Outcome of automated pipeline analysis
    outcome_pipeline = case_when(
    
    min_region_fold_change <= deletion_fc_threshold &
      wgs_result == "Deletion detected" ~"true_positive",
    
    min_region_fold_change > deletion_fc_threshold &
      wgs_result == "No deletion detected" ~"true_negative",
    
    min_region_fold_change <= deletion_fc_threshold &
      wgs_result == "No deletion detected" ~"false_positive",
    
    min_region_fold_change > deletion_fc_threshold &
      wgs_result == "Deletion detected" ~"false_negative"),
    
    outcome_pipeline = factor(outcome_pipeline, levels = 
                                c("true_positive",     # Order for 
                                  "false_positive",    # epiR::epi.tests
                                  "false_negative",    # dat argument
                                  "true_negative")),
    # Outcome of combined pipeline analysis and manual review
    outcome_combined = case_when(
      
      pansolid_result_combined == "deletion" &
        wgs_result == "Deletion detected" ~"true_positive",
      
      pansolid_result_combined == "no deletion" &
        wgs_result == "No deletion detected" ~"true_negative",
      
      pansolid_result_combined == "deletion" &
        wgs_result == "No deletion detected" ~"false_positive",
      
      pansolid_result_combined == "no deletion" &
        wgs_result == "Deletion detected" ~"false_negative"),
    
    # Manually recode result with low p value and
    # different transcript used by WGS
    outcome_combined = case_when(
      labno.x == "24031053" & gene == "SUFU" &
        pansolid_result == "deletion" ~"true_negative",
      labno.x == "24025266" & gene == "CDKN2A" &
        wgs_result == "No deletion detected" ~"true_positive",
      TRUE ~outcome_combined),
    
    outcome_combined = factor(outcome_combined, 
                              levels = c("true_positive",     
                                         "false_positive",    
                                         "false_negative",    
                                         "true_negative"
                                         )),
    ccube_ncc = parse_number(calculated_tumour_content))

pipeline_manual_discrepancies <- pansolid_vs_wgs_outcomes |> 
  filter(pansolid_result == "deletion" &
           analyst_result == "no deletion")

```

```{r}
#| label: check-pansolid-to-wgs-comparison
#| include: FALSE

stopifnot(anyNA(pansolid_vs_wgs_outcomes$outcome_pipeline) == FALSE)

stopifnot(anyNA(pansolid_vs_wgs_outcomes$outcome_combined) == FALSE)

stopifnot(nrow(pansolid_vs_wgs_outcomes) == nrow(pansolid_samples_for_wgs_comparison) *
  length(del_genes))

del_gene_string <- str_c(del_genes, collapse = ",")

pansolid_vs_wgs_gene_strings <- pansolid_vs_wgs_outcomes |> 
  group_by(labno.x) |> 
  summarise(gene_number = length(gene),
            gene_string = str_c(gene, collapse = ",")) |> 
  mutate(gene_check = case_when(
    gene_string == del_gene_string ~"pass",
    gene_string != del_gene_string ~"fail"
  ))

stopifnot(pansolid_vs_wgs_gene_strings$gene_check == "pass")

```

```{r}
#| label: tbl-wgs-comparison-sample-summary
#| tbl-cap: "Details of samples used in the PanSolid-WGS comparison. Pathology
#| identifiers for PanSolid are taken from the DNA database. Pathology 
#| identifiers for WGS are taken from the WGS HTML reports."
#| echo: FALSE

tbl_wgs_comparison_summary <- pansolid_vs_wgs_outcomes |> 
  select(labno.x, labno.y, worksheet, extraction_method, 
         pathno, wgs_pathno, cancer) |> 
  distinct() |>  
  filter(!is.na(labno.y)) |> 
  rename(`PanSolid DNA number` = labno.x,
         `WGS DNA number` = labno.y,
        `PanSolid worksheet` = worksheet,
        `PanSolid DNA extraction method` = extraction_method,
        `PanSolid DNA pathology ID` = pathno,
        `WGS DNA pathology ID` = wgs_pathno,
        `Cancer type` = cancer)

kable(tbl_wgs_comparison_summary)

```

### False positive and false negative results {#sec-results-wgs-false-pos-neg}

In some cases, the copy number statuses provided by the PanSolid CNV caller, which
are based on fold change, contrasted with the pattern in the SNP allele frequency
view. For example, the PanSolid pipeline identified certain genes as being 
deleted with fold changes slightly below the `r deletion_fc_threshold` fold change
threshold, whilst
SNP allele frequencies in the same region indicated a normal diploid state.
This was noted in
`r nrow(pipeline_manual_discrepancies)`
gene results in 
`r length(unique(pipeline_manual_discrepancies$labno_suffix_worksheet))`
samples, and in each case the deletion status of the gene was manually annotated
as not having
a deletion. The genes for which this was most commonly performed were *FGFR3* and
*MUTYH*. An example for 
the *MUTYH* gene is shown in @fig-24030951-false-positive.

```{r}
#| label: wgs-false-pos-image
#| include: FALSE

path_24030951 <- paste0(image_folderpath,
                        "24030951_false_positive.png")

caption_24030951 <- "For this sample, PanSolid NGS 
(24030951, WS143415, panel: v2PANSOLID) identified a partial deletion in 
the *MUTYH* gene on chromosome 1 with a fold change of -1.28
(highlighted in the red box). However, 
the ploidy caller and SNP profile at the *MUTYH* locus both indicate a normal 
diploid result (black arrow). WGS on DNA from fresh frozen tissue 
from the same pathology 
block (23018367) did not detect a deletion in *MUTYH*."

```

![`r caption_24030951`](`r path_24030951`){#fig-24030951-false-positive height=5in}

In other cases, the reverse scenario was observed: the PanSolid pipeline 
categorised genes as not being deleted with fold changes slightly above the
`r deletion_fc_threshold` fold change threshold, whilst
SNP allele frequencies indicated the loss of a large chromosomal region. An 
example is shown in @fig-23024575-false-neg.

```{r}
#| label: wgs-false-neg-image
#| include: FALSE

path_23024575 <- paste0(image_folderpath,
                        "23024575_false_negative.png")

caption_23024575 <- "WGS for this sample shows a loss of chromosome 10
(23024547). On 
PanSolid, the CLC ploidy caller also detects this loss and deletions are 
detected in *BMPR1A* and *PTEN*. However, *FGFR2* and *SUFU*, also on 
chromosome 10, are not identified as deletions on PanSolid 
(23024575 WS141565, panel: v2PANSOLID) as they have 
fold changes of -1.23 which are just below the fold change threshold of-1.25."

```

![`r caption_23024575`](`r path_23024575`){#fig-23024575-false-neg height=5in}

```{r}
#| label: p-values
#| eval: FALSE
#| include: FALSE

pansolid_vs_wgs_outcomes |> 
  filter(outcome_pipeline %in% c("false_positive", "true_positive")) |> 
  mutate(p_value_category  = case_when(
    p_value == 0 ~"0",
    p_value > 0 ~"Above 0"
  )) |> 
  filter(!is.na(p_value_category)) |> 
  group_by(outcome_pipeline, p_value_category) |> 
  count() 

  pivot_wider(id_cols = outcome_pipeline,
              names_from = p_value_category,
              values_from = n) |> 
  rename(zero = `0`,
         above_zero = `Above 0`) |> 
  mutate(zero_percent = round((zero / (zero + above_zero))*100, 1),
         above_zero_percent = round((above_zero / (zero + above_zero))*100, 1),
         p_value_zero = str_c(zero, " (", zero_percent, "%)"),
         p_value_above_zero = str_c(above_zero, " (", above_zero_percent, "%)"),
         results = zero + above_zero) |> 
  select(outcome_pipeline, results, p_value_zero, p_value_above_zero)

```


### Haploidy and polyploidy

The CLC Detect Regional Ploidy Tool does not calculate ploidy at the whole
genome level. The WGS sample cohort was deliberately selected to represent a range of 
genome ploidy states, with the Genomics England pipeline detecting whole
genome ploidy ranging from hexpaloidy (overall ploidy: 
`r max(del_val_wgs_html_ids$calculated_overall_ploidy)`) to a sample
with haploidy (overall ploidy: 
`r min(del_val_wgs_html_ids$calculated_overall_ploidy)`) 
(@tbl-wgs-pansolid-ploidy).

```{r}
#| label: wgs-ploidy
#| include: FALSE

tbl_wgs_pansolid_ploidy <- pansolid_vs_wgs_outcomes |> 
  left_join(
    del_val_wgs_html_ids |> 
      select(nhsno, labno, calculated_overall_ploidy,
             calculated_chromosome_count) |> 
      rename(wgs_ploidy = calculated_overall_ploidy,
             wgs_chrom_count = calculated_chromosome_count,
             wgs_labno = labno),
    by = "nhsno") |> 
  filter(wgs_ploidy < 1.5 |
           wgs_ploidy > 2.5) |> 
  group_by(labno.x, wgs_labno, 
           wgs_ploidy, wgs_chrom_count, outcome_pipeline) |> 
  count() |> 
  pivot_wider(id_cols = c(labno.x, wgs_labno, wgs_ploidy,
                          wgs_chrom_count),
              names_from = outcome_pipeline,
              values_from = n,
              values_fill = 0) |>  
  arrange(wgs_ploidy) |>
  select(-c(true_positive, true_negative)) |>  
  adorn_totals(,,,, false_positive, false_negative) |> 
  rename(`DNA number (PanSolid)` = labno.x,
         `DNA number (WGS)` = wgs_labno,
         `Ploidy detected by WGS` = wgs_ploidy,
         `Chromosome count detected by WGS` = wgs_chrom_count,
         `False positives` = false_positive,
         `False negatives` = false_negative)
  
```

```{r}
#| label: tbl-wgs-pansolid-ploidy
#| tbl-cap: "WGS ploidy samples tested on PanSolid"
#| echo: FALSE

kable(tbl_wgs_pansolid_ploidy)

```

For the haploid sample (24062632, panel: v2PANSOLID), the PanSolid pipeline
did not account for the reduced chromosome dosage across the majority of the
genome, and measured gene dosage from this reduced baseline. This led
to an inversion of the results from WGS: deleted regions
were detected as normal dosage, and normal dosage regions were detected as 
gains (@fig-24062632-haploid-false-negative).

```{r}
#| label: wgs-false-neg-image-ploidy
#| include: FALSE

path_24062632 <- paste0(image_folderpath,
                        "24062632_haploid_false_negative.png")

caption_24062632 <- "WGS for this tumour sample showed a haploid genome 
(24062650, ploidy: 1.2, NCC: 78.6%) with diploid copy number of chromosomes 5, 7, 13, 
16, 19 and 20. Conversely, on PanSolid NGS performed on an FFPE sample for the
same tumour (24062632, panel: v2PANSOLID) these chromosomes are 
classified as gains, with the rest of the 
genome classified as copy-neutral LOH by the ploidy caller. This leads to
false negative results for the genes on these chromosomes."

```

![`r caption_24062632`](`r path_24062632`){#fig-24062632-haploid-false-negative height=5in}

The reverse was observed for 
`r nrow(tbl_wgs_pansolid_ploidy)-2`
samples defined by the Genomics England WGS pipeline as being polyploid. In these
cases, the PanSolid pipeline identified some gene regions as deleted which 
were not identified as deleted by WGS. This was because, whilst WGS detected
a relative loss of dosage for these genes compared to the overall genome
ploidy level, the absolute number of copies was 2 or above. An example is shown
in @fig-24045841-false-positive-hexaploid. The details for each polyploid sample
are shown in @tbl-wgs-pansolid-ploidy

```{r}
#| label: wgs-false-pos-image-ploidy
#| include: FALSE

path_24045841 <- paste0(image_folderpath,
                        "24045841_false_positive_hexaploid.png")

caption_24045841 <- "WGS for this tumour sample showed a hexaploid genome 
(ploidy: 5.49, NCC: 56.7%). Several chromosomes, including 8, 10 and 13 
(black arrows), have copy numbers of 3-4 and have a low relative dosage 
comparative to the overall ploidy (black dashed line). PanSolid NGS, 
performed on an FFPE sample from the same tumour block
(24042543, WS146593, panel: v2PANSOLID), detects these 
relative losses as deletions for 4 target genes (chr8: *FGFR1*; chr10: *PTEN*; 
chr13: *BRCA2* and *RB1*), which are subsequently classed as false positives.
However, a biallelic deletion of the *CDKN2A* deletion is still correctly
identified."

```

![`r caption_24045841`](`r path_24045841`){#fig-24045841-false-positive-hexaploid height=5in}

### Sensitivity and specificity 

The sensitivity and specificity of the PanSolid pipeline compared to WGS were
calculated in 3 ways: first the initial outputs of the PanSolid pipeline were
compared; then the results following manual review of each detected CNV, which
accounted for occasional discrepancies with the SNP allele frequencies
(@sec-results-wgs-false-pos-neg); and finally for only those samples confirmed
as diploid (overall ploidy 1.5-2.5) by WGS, which accounted for discrepancies
due to ploidy. The results are shown in @tbl-pansolid-wgs-metrics. 

```{r}
#| label: pansolid-wgs-sensitivity
#| include: FALSE

diploid_wgs_samples <- del_val_wgs_html_ids |> 
  filter(calculated_overall_ploidy > 1.5 & 
           calculated_overall_ploidy < 2.5)

wgs_outcomes_pipeline <- pansolid_vs_wgs_outcomes |> 
  group_by(outcome_pipeline) |> 
  count(.drop = FALSE) 

wgs_pipeline_se_sp <- make_se_sp_table(wgs_outcomes_pipeline$n) |> 
  mutate(analysis = "CNV caller")  

wgs_outcomes_combined <- pansolid_vs_wgs_outcomes |> 
  group_by(outcome_combined) |> 
  count(.drop = FALSE) 

wgs_combined_se_sp <- make_se_sp_table(wgs_outcomes_combined$n) |> 
  mutate(analysis = "CNV caller with manual review")  

wgs_outcomes_combined_diploid <-  pansolid_vs_wgs_outcomes |> 
  filter(nhsno %in% diploid_wgs_samples$nhsno) |> 
  group_by(outcome_combined) |> 
  count(.drop = FALSE)

wgs_combined_diploid_se_sp <- make_se_sp_table(wgs_outcomes_combined_diploid$n) |> 
  mutate(analysis = "CNV caller with manual review (diploid samples)")

wgs_outcome_table <- rbind(wgs_pipeline_se_sp,
                           wgs_combined_se_sp,
                           wgs_combined_diploid_se_sp) |> 
  mutate(`Samples` = (`True positives` + `True negatives` +
           `False positives` + `False negatives`) / length(del_genes)) |> 
  relocate(analysis) |> 
  relocate(`Samples`, .after = analysis) |> 
  rename(`Analysis` = analysis)

```

```{r}
#| label: tbl-pansolid-wgs-metrics
#| tbl-cap: "PanSolid vs WGS metrics"
#| echo: FALSE

knitr::kable(wgs_outcome_table)

```

Following manual review of CNV calls in diploid samples, there were 8 discrepant
results between PanSolid and WGS. These results are summarised in
@tbl-wgs-discrepant_results and individually reviewed below. The DNA numbers in 
bold are the identifiers for the PanSolid results.

 - **24035922**: PanSolid detected a deletion in *BMPR1A* which was not detected
 on WGS (WGS DNA number: 24036644). The deletion call included only 
 one target of *BMPR1A*, 
 and was caused
 by a biallelic deletion of the nearby *PTEN* gene. 
 
 - **23013975**: a deletion of chromosome 1p was detected on WGS (WGS DNA
 number: 23013975), and identified
 by the ploidy caller on PanSolid, however the fold change of the *MUTYH* gene
 was slightly above the `r deletion_fc_threshold` threshold and so was not 
 identified as being deleted.

- **23024575**: a chromosome 10 deletion was detected on WGS and PanSolid
 (WGS DNA number: 23024547), but
the fold changes of the *SUFU* and *FGFR2* genes were slightly above the 
`r deletion_fc_threshold` threshold. This sample is shown in @fig-23024575-false-neg.

- **24019998**: deletions of *FH* (chromosome 1p) and *CDH1* (chromosome 16q) 
were detected on WGS (WGS DNA number: 24024109), but not on PanSolid. 
Evidence of chromosomal changes
at 1p and 16q were visible on PanSolid but had been identified as copy neutral
LOH and a gain, respectively, by the Detect Regional Ploidy Tool. Deletions in
12 other target genes were successfully detected for this sample.

```{r}
#| label: tbl-wgs-discrepant_results
#| tbl-cap: "WGS discrepant results"
#| echo: FALSE

wgs_discrepant_results <- pansolid_vs_wgs_outcomes |> 
  filter(nhsno %in% diploid_wgs_samples$nhsno) |>
  filter(outcome_combined %in% c("false_positive",
                                 "false_negative")) |>  
  left_join(del_val_wgs_html_ids |> 
              select(nhsno, labno, calculated_tumour_content) |> 
              rename(wgs_labno = labno),
            by = "nhsno") |> 
  select(labno.x, wgs_labno,
         gene, min_region_fold_change, calculated_tumour_content.y,
         wgs_result, outcome_combined, percent_138x, stdev_noise) |> 
  arrange(outcome_combined) |> 
  mutate(`Minimum fold change` = round(min_region_fold_change, 3)) |> 
  relocate(`Minimum fold change`, .after = gene) |> 
  rename(`PanSolid DNA number` = labno.x,
         `WGS DNA number` = wgs_labno,
         `Gene` = gene,
         `WGS result` = wgs_result,
         `Outcome` = outcome_combined) |> 
  select(-min_region_fold_change)
  
kable(wgs_discrepant_results)

```

```{r}
#| label: fig-pansolid-wgs-counts-plot
#| fig-cap: "PanSolid vs WGS by gene. Genes are ordered by chromosome number."
#| fig-height: 8
#| fig-width: 6
#| eval: FALSE
#| include: FALSE

pansolid_wgs_for_plot <- pansolid_vs_wgs_outcomes |> 
  mutate(plot_outcome = case_when(
    outcome_combined == "true_positive" ~"True positives",
    outcome_combined == "true_negative" ~"True negatives",
    outcome_combined == "false_positive" ~"False positives",
    outcome_combined == "false_negative" ~"False negatives"),
    
    plot_outcome = factor(plot_outcome, levels = c("True negatives",
                                              "True positives",
                                              "False negatives",
                                              "False positives")))

fig_pansolid_wgs_counts_plot <- pansolid_wgs_for_plot |> 
  group_by(chrom_num, gene, plot_outcome) |> 
  count() |> 
  ggplot(aes(x = reorder(gene, chrom_num), y = n)) +
  geom_col(fill = "#3399FF", colour = "black") +
  facet_wrap(~plot_outcome, nrow = 4, axes = "all_x") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90),
        legend.position = "bottom") +
  labs(x = "", y = "Results",
       title = "PanSolid vs WGS: gene level results") +
  scale_y_continuous(breaks = c(0, 10, 20))

fig_pansolid_wgs_counts_plot

```

### Monoallelic and biallelic deletions {#sec-results-bi-mono-deletions}

There was a clear relationship between the fold change measured by the PanSolid
pipeline and the overall gene copy number from WGS
(@fig-copy-number-vs-fold-change). All biallelic gene deletions with copy 
numbers of 0 on WGS were detected as deletions by PanSolid, even in non-diploid
samples, except for a 
germline *CDKN2A* deletion in sample 24048159 (panel: v2PANSOLID), which only
impacted the *CDKN2A*
NM_000077.5 transcript. This deletion is expected to be detected when the
pipeline graining level for *CDKN2A* is changed to "fine". The sensitivity 
values for 
detection of confirmed monoallelic and biallelic deletions in all samples and
in confirmed diploid samples 
are shown in @tbl-bi-mono-del-detection. Notably, biallelic deletions can
be successfully detected in polyploid samples, whilst the sensitivity for 
detecting monoallelic deletions is greatly reduced versus the sensitivity for
diploid samples.

```{r}
#| label: fig-copy-number-vs-fold-change
#| fig-cap: "Copy number vs fold change"
#| echo: FALSE

fig_copy_number_vs_fold_change <- pansolid_vs_wgs_outcomes |> 
  mutate(cnv_copy_number = case_when(
    is.na(cnv_copy_number) ~2,
    TRUE ~cnv_copy_number
  )) |> 
  ggplot(aes(x = cnv_copy_number, y = min_region_fold_change)) +
  annotate('rect', 
           xmin = 0, xmax = 10, ymin = -1, ymax = 1, 
           fill='grey', alpha = 0.5) +
  scale_x_continuous(breaks = seq(0, 10, by = 1)) +
  geom_jitter(shape = 21, width = 0.1) +
  theme_bw() +
  geom_hline(yintercept = deletion_fc_threshold, linetype = "dashed") +
  scale_y_continuous(breaks = c(seq(-20, 5, by = 5), deletion_fc_threshold)) +
  labs(x = "WGS copy number", y = "PanSolid minimum fold change") +
  ggpubr::stat_cor(method = "pearson", label.x = 5, label.y = -10) 

fig_copy_number_vs_fold_change

```

```{r}
#| label: tbl-bi-mono-del-detection
#| tbl-cap: "Detection rate of monoallelic and biallelic deletions"
#| echo: FALSE

bi_mono_gene_counts_all <- pansolid_vs_wgs_outcomes |> 
  filter(cnv_copy_number %in% c(0, 1)) |> 
  group_by(cnv_copy_number) |> 
  summarise(genes = length(unique(gene)),
            samples = length(unique(labno.x)))

bi_mono_gene_counts_diploid <- pansolid_vs_wgs_outcomes |> 
  filter(cnv_copy_number %in% c(0, 1) 
         & nhsno %in% diploid_wgs_samples$nhsno
         ) |> 
  group_by(cnv_copy_number) |> 
  summarise(genes = length(unique(gene)),
            samples = length(unique(labno.x)))

biallelic_del_results_all <- pansolid_vs_wgs_outcomes |> 
  filter(cnv_copy_number == 0) |> 
  group_by(cnv_copy_number, outcome_combined) |> 
  count(outcome_combined, .drop = FALSE)

biallelic_del_results_diploid <- pansolid_vs_wgs_outcomes |> 
  filter(cnv_copy_number == 0 
         & nhsno %in% diploid_wgs_samples$nhsno
         ) |> 
  group_by(cnv_copy_number, outcome_combined) |> 
  count(outcome_combined, .drop = FALSE)

biallelic_se_sp_all <- make_se_sp_table(biallelic_del_results_all$n) |> 
  mutate(deletion = "Biallelic",
         cnv_copy_number = 0)

biallelic_se_sp_diploid <- make_se_sp_table(biallelic_del_results_diploid$n) |> 
  mutate(deletion = "Biallelic",
         cnv_copy_number = 0)

monoallelic_del_results_all <- pansolid_vs_wgs_outcomes |> 
  filter(cnv_copy_number == 1) |> 
  group_by(cnv_copy_number, outcome_combined) |> 
  count(outcome_combined, .drop = FALSE)

monoallelic_del_results_diploid <- pansolid_vs_wgs_outcomes |> 
  filter(cnv_copy_number == 1 
         & nhsno %in% diploid_wgs_samples$nhsno
         ) |> 
  group_by(cnv_copy_number, outcome_combined) |> 
  count(outcome_combined, .drop = FALSE)

monoallelic_se_sp_all <- make_se_sp_table(monoallelic_del_results_all$n) |> 
  mutate(deletion = "Monoallelic",
         cnv_copy_number = 1) 

monoallelic_se_sp_diploid <- make_se_sp_table(monoallelic_del_results_diploid$n) |> 
  mutate(deletion = "Monoallelic",
         cnv_copy_number = 1) 

bi_mono_allelic_results_all <- rbind(biallelic_se_sp_all,
                                monoallelic_se_sp_all) |> 
  ungroup() |> 
  left_join(bi_mono_gene_counts_all, by = "cnv_copy_number") |> 
  mutate(cohort = "All samples")

bi_mono_allelic_results_diploid <- rbind(biallelic_se_sp_diploid,
                                monoallelic_se_sp_diploid) |> 
  ungroup() |> 
  left_join(bi_mono_gene_counts_diploid, by = "cnv_copy_number") |> 
  mutate(cohort = "Diploid samples only")


bi_mono_del_table <- rbind(bi_mono_allelic_results_all,
     bi_mono_allelic_results_diploid ) |> 
  select(-c(cnv_copy_number,
            `False positives`, `True negatives`, `Specificity (%)`)) |> 
  relocate(deletion) |> 
  relocate(samples, .after = deletion) |> 
  relocate(genes, .after = samples) |> 
  relocate(cohort, .before = deletion) |> 
  rename(`Deletions` = deletion,
         `Genes` = genes,
         `Cohort` = cohort,
         `Samples` = samples)

kable(bi_mono_del_table)

```

```{r}
#| label: fig-bi-mono-del-fold-change
#| fig-cap: "Fold change of biallelic and monoallelic deletions"
#| echo: FALSE
#| fig-width: 6

del_line_df <- fold_change_df |> 
  rename(ccube_ncc = ncc)

bi_mono_fc_plot <- pansolid_vs_wgs_outcomes |> 
  mutate(fold_change = case_when(
    min_region_fold_change <= -1 ~min_region_fold_change,
    min_region_fold_change >= 1 ~change(min_region_fold_change,
                                        from = "fcgain", to = "fcloss"))) |> 
  filter(cnv_copy_number %in% c(0, 1)) |>
  mutate(cnv_copy_number_char = case_when(
    cnv_copy_number == 0 ~"Biallelic deletions on WGS",
    cnv_copy_number == 1 ~"Monoallelic deletions on WGS"
  )) |> 
  select(labno.x, gene, cnv_copy_number_char, 
         ccube_ncc, fold_change) |> 
  ggplot(aes(x = ccube_ncc, y = fold_change)) +
  geom_line(data = del_line_df,
            aes(colour = del_state), linewidth = 1) +
  scale_colour_manual(values = c( "#999999", "#999999", "#999999")) +
  geom_point(shape = 21, size = 2, fill = "white") +
  scale_x_continuous(limits = c(0, 100),
                     breaks = seq(0, 100, by = 10)) +
  scale_y_continuous(limits = c(-20, 0)) +
  facet_wrap(~cnv_copy_number_char) +
  theme_bw() +
  theme(legend.position = "none") +
  labs(x = "Neoplastic cell content (Ccube)",
       y = "PanSolid fold change") +
  annotate("text", x = 85, y = -15, label = "Biallelic") +
  annotate("text", x = 90, y = -3, label = "Monoallelic") +
  annotate("text", x = 90, y = 0, label = "Normal")

bi_mono_fc_plot

```

```{r}
#| label: pansolid-loh-vs-wgs
#| eval: FALSE
#| include: FALSE

pansolid_loh_for_wgs_comp <- del_val_collated_loh_mod |> 
  filter(stdev_noise <= noise_qc_threshold &
           percent_138x >= percent_138x_qc_threshold) |> 
  left_join(del_val_sample_patient_info |> 
              select(labno, nhsno, extraction_method),
            by = "labno") |> 
  filter(nhsno %in% del_val_wgs_html_ids$nhsno) |> 
  filter(
    (nhsno %in% patients_with_qiasymphony_extractions$nhsno &
    extraction_method == "QIAsymphony") |
      (!nhsno %in% patients_with_qiasymphony_extractions$nhsno)) |> 
  filter(!labno %in% c(
    "23025733",                # Remove sample on Cobas extraction
    "24030946",                # These patients have 2 QIAsymphony extractions
    "24018922",                # This sample is from a different path block
    "24033015"                 # Also from a different path block - see note
    )) |>                      # on iGene
  # This sample was repeated for repeatability
  filter((labno != "24017319" & worksheet != "WS144364")) |> 
  filter((labno != "24053299" & worksheet != "WS150529")) |> 
  filter(!labno_suffix %in% c("24026628a", "24026628b", "24026628c",
                              "24026628d"))

pansolid_loh_vs_wgs <- pansolid_loh_for_wgs_comp |> 
  left_join(wgs_results_for_pansolid_comparison |> 
              filter(nhsno %in% diploid_wgs_samples$nhsno),
            join_by(nhsno == nhsno, gene == gene),
            relationship = "one-to-one")

```

### Neoplastic cell content comparison

The CLC Regional Ploidy Tool predicts the NCC of a sample as part of its HMM 
approach to deconvoluting ploidy states. The NCC predictions from CLC were 
compared to the predictions from the WGS results, which were calculated using
the Canvas algorithm [@fig-wgs-ncc-comparison].

```{r}
#| label: wgs-ncc-comparison
#| include: FALSE

pansolid_vs_wgs_ncc <- noise_138x_ncc |>  
  left_join(del_val_sample_patient_info,
            by = "labno") |> 
  filter(nhsno %in% del_val_wgs_html_ids$nhsno) |> 
  filter(stdev_noise <= noise_qc_threshold &
           percent_138x >= percent_138x_qc_threshold) |>  
  left_join(del_val_wgs_html_ids, 
            by = "nhsno") |> 
  mutate(ccube_ncc = parse_number(calculated_tumour_content))

ncc_comp_same_dnas <- pansolid_vs_wgs_ncc |> 
  filter(labno.x == labno.y) 

ncc_comp_diff_dnas <- pansolid_vs_wgs_ncc |> 
  filter(labno.x != labno.y) |>  
  filter(is.na(suffix)) |> 
  # Remove samples with non-matching pathology blocks
  filter(!labno.x %in% c("24018922", "24033015",
                         # Contaminated samples
                         "24030945","24030962"
                         )) |>  
  filter(!duplicated(nhsno)) 

ncc_same_dna_plot <- ncc_comp_same_dnas |> 
  filter(!is.na(ccube_ncc)) |>
  ggplot(aes(x = pred_ncc, y = ccube_ncc)) +
  geom_point(shape = 21, size = 2) +
  ylim(0, 100) +
  xlim(0, 100) +
  geom_abline(linetype = "dashed") +
  theme_bw() +
  labs(x = "CLC predicted NCC (%)", 
       y = "WGS predicted NCC (%)",
       title = "Same DNA samples")

ncc_diff_dna_plot <- ncc_comp_diff_dnas |> 
  filter(!is.na(ccube_ncc)) |>
  ggplot(aes(x = pred_ncc, y = ccube_ncc)) +
  geom_point(shape = 21, size = 2) +
  ylim(0, 100) +
  xlim(0, 100) +
  geom_abline(linetype = "dashed") +
  theme_bw() +
  labs(x = "CLC predicted NCC (%)", 
       y = "WGS predicted NCC (%)",
       title = "Different DNA samples")

wgs_ncc_plot <- ncc_diff_dna_plot + ncc_same_dna_plot +
  plot_layout(ncol = 2)

```

```{r}
#| label: fig-wgs-ncc-comparison
#| echo: FALSE

wgs_ncc_plot

```

{{< pagebreak >}}

## Comparison to ddPCR

```{r}
#| label: load-ddpcr-data
#| include: FALSE

qs_normals <- read_csv(file = paste0(data_folderpath,
                                     "validation/DOC6283_amplifications/",
                                     "controls/qiasymphony_controls.csv"),
                       col_types = "c")

ddpcr_data_mod <- del_val_ddpcr_collated |> 
  filter(sample != "NTC") |> 
  filter(target_type == "Ch1Unknown") |> 
  mutate(category = case_when(
    sample %in% qs_normals$labno ~"normal control",
    TRUE ~"patient"
  ))

```

```{r}
#| label: compare-ddpcr-pansolid
#| include: FALSE

pansolid_vs_ddpcr <- ddpcr_data_mod |> 
  left_join(del_val_collated_del_genes |> 
              mutate(labno = case_when(
                # Change to the numbers for fresh frozen DNA, 
                # which was used for ddPCR
                labno == "24025211" & gene %in% c("CDKN2A", "PTEN") ~"24027848",
                labno == "24030951" & gene %in% c("CDKN2A", "PTEN") ~"23018367",
                TRUE ~labno)), 
            join_by("sample" == "labno", "gene" == "gene")) |> 
  left_join(sig_cnvs_for_join, 
            join_by(labno_suffix_worksheet, gene)) |> 
  mutate(
    pansolid_result_combined = case_when(
      is.na(analyst_result) ~pansolid_result,
      !is.na(analyst_result) ~analyst_result),
    pansolid_result_combined = case_when(
      # Deletion call doesn't include ddPCR assay
    sample == "24047809" & gene == "PTEN" ~"no deletion",
    # Small deletion visible on PanSolid
    sample == "24048159" & gene == "CDKN2A" ~"deletion",
    TRUE ~pansolid_result_combined),
    sub_category = case_when(
    category != "normal control" ~paste0(category, " ", pansolid_result_combined),
    TRUE ~category
  ),
  sub_category = factor(sub_category,
                        levels = c("normal control",
                                   "patient no deletion",
                                   "patient deletion")),
  ddpcr_result = case_when(
    cnv >= 1.4 ~"no deletion",
    cnv <= 1.4 ~"deletion"
  ),
  ddpcr_result = factor(ddpcr_result, levels = c("no deletion",
                                                 "deletion")),
  outcome = case_when(
    pansolid_result_combined == "deletion" &
      ddpcr_result == "deletion" ~"true_positive",
    pansolid_result_combined == "no deletion" &
      ddpcr_result == "no deletion" ~"true_negative",
    pansolid_result_combined == "deletion" &
      ddpcr_result == "no deletion" ~"false_positive",
    pansolid_result_combined == "no deletion" &
      ddpcr_result == "deletion" ~"false_negative",
    TRUE ~"no result"
  ),
  outcome = factor(outcome, levels = c("true_positive",
                                       "false_positive",
                                       "false_negative",
                                       "true_negative",
                                       "no result"))) |> 
  filter(sample != "24034335")

ddpcr_sample_summary <- pansolid_vs_ddpcr |> 
  group_by(sub_category) |> 
  summarise(samples = length(unique(sample))) |> 
  janitor::adorn_totals()

control_ddpcr_results_cdkn2a <- pansolid_vs_ddpcr |> 
  filter(sub_category == "normal control" & gene == "CDKN2A") |> 
  arrange(cnv) |> 
  select(sample, cnv)

control_ddpcr_results_pten <- pansolid_vs_ddpcr |> 
  filter(sub_category == "normal control" & gene == "PTEN")

ddpcr_patients <- ddpcr_sample_summary[2,2] +ddpcr_sample_summary[3,2]

normals_below_ddpcr_threshold <- pansolid_vs_ddpcr |> 
  filter(sub_category == "normal control" &
           cnv < 1.4)

```

ddPCR was performed for the *PTEN* and *CDKN2A* genes for all 
`r ddpcr_sample_summary[1,2]`
samples used
in the normal control pool by the PanSolid CLC pipeline, and for 
`r ddpcr_patients` samples from
the validation cohort. x samples were also tested by WGS.
The *CDKN2A* ddPCR assay 
(amplicon coordinates:  GRCh38 chr9: 21,968,120-21,968,172) 
targeted the 3rd exon of *CDKN2A*, which
is present in both the NM_000077.5 and NM_058195.4 transcripts
(@fig-cdkn2a-locus). The *PTEN* ddPCR assay
(amplicon coordinates: GRCh38 chr10: 87,864,384-87,864,484)
targeted the first exon of *PTEN*. One sample (24034335) was excluded from the
analysis due to a copy number gain on chromosome 5 which spanned the locus of 
the *AP3B1* reference gene. The *AP3B1* gene is not targeted by the PanSolid
enrichment and is located at chr5:78000522-78294698 (GRCh38) between PanSolid
targets "chr5:76.7Mb" and "chr5:77.7Mb". Another sample (24047809) with am
intragenic *PTEN* deletion detected on PanSolid was coded as "no deletion" 
because the deletion coordinates did not overlap with the coordinartes of the
*PTEN* exon 1 ddPCR assay.
There was wide variation 
in the copy numbers determined within the control 
cohort, ranging from 
`r round(min(control_ddpcr_results_cdkn2a$cnv), 1)`-
`r round(max(control_ddpcr_results_cdkn2a$cnv), 1)`
(mean `r round(median(control_ddpcr_results_cdkn2a$cnv), 1)`) for *CDKN2A*, 
and from
`r round(min(control_ddpcr_results_pten$cnv), 1)`-
`r round(max(control_ddpcr_results_pten$cnv), 1)`
(median `r round(median(control_ddpcr_results_pten$cnv), 1)`) for *PTEN*. 
A copy number threshold of 1.4 was used for the categorisation of results as
normal or deleted, although the *CDKN2A* copy numbers for 2 normal control 
samples (24012050, R24-0AKB, skin and 24012073, R24-0AJR, prostate) fell below this threshold
(@fig-ddpcr-pansolid-outcomes). 

Using this threshold, 91.4% of ddPCR and PanSolid
results were concordant (@tbl-pansolid-ddpcr-metrics). The sample with a small
germline deletion of CDKN2A (24048159) had a *CDKN2A* ddPCR copy number of 0.25.

```{r}
#| label: fig-ddpcr-pansolid-outcomes
#| fig-cap: "PanSolid results vs ddPCR. Note the ordering of samples is 
#| different on each plot."
#| echo: FALSE
#| fig-width: 6
#| fig-height: 7

cdkn2a_ddpcr_for_plot <- pansolid_vs_ddpcr |> 
  filter(gene == "CDKN2A") |> 
  filter(!duplicated(sample)) |> 
  arrange(sub_category, desc(cnv)) |> 
  mutate(sample_order = factor(sample,
                               levels = sample))

pten_ddpcr_for_plot <-  pansolid_vs_ddpcr |> 
  filter(gene == "PTEN") |> 
  filter(!duplicated(sample)) |> 
  arrange(sub_category, desc(cnv)) |> 
  mutate(sample_order = factor(sample,
                               levels = sample))

cdkn2a_ddpcr_plot <- cdkn2a_ddpcr_for_plot |> 
  ggplot(aes(x = sample_order, y = cnv)) +
  geom_hline(yintercept = 1.4, linetype = "dashed") +
  geom_errorbar(aes(ymin = poisson_cnv_max, ymax = poisson_cnv_min)) +
  geom_point(aes(shape = sub_category), fill = "white") +
  scale_shape_manual(values = c(21, 22, 25)) +
  theme_bw() +
  scale_y_continuous(limits = c(0, 5.5),
                     breaks = c(0, 1, 1.4, 2, 3, 4, 5),
                     minor_breaks = FALSE) +
  theme(axis.text.x = element_blank(),
        legend.position = "none") +
  labs(x = "", y = "ddPCR copy number",
       shape = "PanSolid result",
       title = "CDKN2A ddPCR results")

pten_ddpcr_plot <- pten_ddpcr_for_plot |> 
  ggplot(aes(x = sample_order, y = cnv)) +
  geom_hline(yintercept = 1.4, linetype = "dashed") +
  geom_errorbar(aes(ymin = poisson_cnv_max, ymax = poisson_cnv_min)) +
  geom_point(aes(shape = sub_category), fill = "white") +
  scale_shape_manual(values = c(21, 22, 25)) +
  theme_bw() +
  scale_y_continuous(limits = c(0, 3.5),
                     breaks = c(0, 1, 1.4, 2, 3),
                     minor_breaks = FALSE) +
  theme(axis.text.x = element_blank(),
        legend.position = "bottom") +
  labs(x = "Sample", y = "ddPCR copy number",
       shape = "PanSolid result",
       title = "PTEN ddPCR results")

cdkn2a_ddpcr_plot + pten_ddpcr_plot + plot_layout(nrow = 2)
  
```

```{r}
#| label: fig-pansolid-fold-change-vs-ddpcr
#| fig-cap: "PanSolid fold change vs ddPCR. Grey line shows predicted fold
#| change based on ddPCR copy number"
#| echo: FALSE
#| fig-width: 6

ddpcr_plot_line_df <- data.frame(
  cnv = seq(0, 3, by = 0.1)) |> 
  mutate(fold_change = pred_fc(tumour_cpc = cnv,
                               ncc = 100,
                               dir = "loss"))

fig_pansolid_fold_change_vs_ddpcr <- pansolid_vs_ddpcr |> 
  filter(category == "patient" &
           !is.na(min_region_fold_change)) |> 
  mutate(fold_change = case_when(
    min_region_fold_change <= -1 ~min_region_fold_change,
    min_region_fold_change >= 1 ~change(min_region_fold_change, 
                                        from = "fcgain", to = "fcloss"))) |> 
  ggplot(aes(x = cnv, y = fold_change)) +
  geom_line(data = ddpcr_plot_line_df, colour = "grey",
            linewidth = 1) +
  geom_point(shape = 21) +
  theme_bw() +
  theme(legend.position = "bottom") +
  facet_wrap(~gene) +
  labs(x = "ddPCR copy number", y = "PanSolid minimum fold change",
       fill = "PanSolid result") +
  coord_cartesian(ylim = c(-30, 5))

fig_pansolid_fold_change_vs_ddpcr

```

```{r}
#| label: tbl-pansolid-ddpcr-metrics
#| tbl-cap: "PanSolid vs ddPCR metrics"
#| echo: FALSE

pansolid_vs_ddpcr_results <- pansolid_vs_ddpcr |> 
  filter(outcome != "no result") |> 
  mutate(outcome = factor(outcome, levels = c("true_positive",
                                       "false_positive",
                                       "false_negative",
                                       "true_negative")))

ddpcr_pten_results <- pansolid_vs_ddpcr_results |> 
  filter(gene == "PTEN") |> 
  group_by(outcome) |> 
   count(outcome, .drop = FALSE)

ddpcr_cdkn2a_results <- pansolid_vs_ddpcr_results |> 
  filter(gene == "CDKN2A") |> 
  group_by(outcome) |> 
   count(outcome, .drop = FALSE)

ddpcr_all_results <- pansolid_vs_ddpcr_results |> 
  group_by(outcome) |> 
  count(outcome, .drop = FALSE)

ddpcr_pten_se_sp <- make_se_sp_table(ddpcr_pten_results$n) |> 
  mutate(cohort = "PTEN")

ddpcr_cdkn2a_se_sp <- make_se_sp_table(ddpcr_cdkn2a_results$n) |> 
  mutate(cohort = "CDKN2A")

pansolid_ddpcr_se_sp <- make_se_sp_table(ddpcr_all_results$n) |> 
  mutate(cohort = "CDKN2A and PTEN")

pansolid_vs_ddpcr_metrics <- rbind(ddpcr_pten_se_sp,
                                   ddpcr_cdkn2a_se_sp,
                                   pansolid_ddpcr_se_sp) |> 
  relocate(cohort) |> 
  rename(`Cohort` = cohort)

knitr::kable(pansolid_vs_ddpcr_metrics)

```

CDKN2A:
24037201 - normal on PanSolid, deletion on ddPCR. Could be a primer binding SNP.

PTEN:
24018632 - normal on PanSolid, deletion on ddPCR

24019905: borderline

ERBB2 validation: "The 29 cobas®-extracted FFPE controls were tested, 
with ddPCR ERBB2 copy numbers ranging from 0.77-6 (median: 1.61)."

Pooled control DNA showed normal dosage (C3, WS146103)

Could be due to FFPE degradation.

{{< pagebreak >}}

## Comparison to *NF2* PCR LOH testing {#sec-results-nf2-loh}

```{r}
#| label: loh-pcr-data
#| include: FALSE

nf2_fragpcr_results <- read_csv(file = paste0(data_folderpath,
                                              "validation/DOC6567_deletions/",
                                              "raw/nf2_loh/",
                                              "nf2_loh_dna_db_results.csv"),
                                col_types = "ccccccdddddcd") |> 
  rename(pcr_median_loh = median_loh,
         pcr_loh = loh_outcome)

pansolid_vs_nf2_loh <- del_val_collated_loh |> 
  filter(gene == "NF2") |> 
  inner_join(nf2_fragpcr_results, by = "labno") |> 
  left_join(del_val_collated_stdev |> 
              select(filepath, stdev_noise), by = "filepath",
            relationship = "one-to-one") |> 
  left_join(del_val_collated_138x |> 
              select(filepath, percent_138x), by = "filepath",
            relationship = "one-to-one") |> 
  left_join(del_val_collated_del_genes |> 
              filter(gene == "NF2") |> 
              select(filepath, min_region_fold_change, 
                     max_region_fold_change),
            by = "filepath",
            relationship = "one-to-one") |> 
  mutate(
    outcome_pipeline = case_when(
      loh_status %in% c("Yes", "Yes, No") &
        pcr_loh == "Significant LOH" ~"true_positive",
      loh_status == "No" &
        pcr_loh == "No significant LOH" ~"true_negative",
      loh_status %in% c("Yes", "Yes, No") &
        pcr_loh == "No significant LOH" ~"false_positive",
      loh_status == "No" &
        pcr_loh == "Significant LOH" ~"false_negative"),
    
    outcome_pipeline = factor(outcome_pipeline, levels = c("true_positive",
                                           "false_positive",
                                           "false_negative",
                                           "true_negative")),
    
    outcome_combined = case_when(
      analyst_result == "LOH" &
        pcr_loh == "Significant LOH" ~"true_positive",
      analyst_result == "no LOH" &
        pcr_loh == "No significant LOH" ~"true_negative",
      analyst_result == "LOH" &
        pcr_loh == "No significant LOH" ~"false_positive",
      analyst_result == "no LOH" &
        pcr_loh == "Significant LOH" ~"false_negative"),
    
    outcome_combined = factor(outcome_combined, 
                              levels = c("true_positive",
                                           "false_positive",
                                           "false_negative",
                                           "true_negative")))

pansolid_vs_nf2_loh_with_qc <- pansolid_vs_nf2_loh |> 
  filter(percent_138x >= 75 & stdev_noise <= 0.7 &
           # Remove sample with contamination
           labno != "24054291")

```

`r nrow(pansolid_vs_nf2_loh)` samples were tested on both the PanSolid CNV and 
NF2 PCR LOH methods. Of these, `r nrow(pansolid_vs_nf2_loh_with_qc)` samples 
passed both NGS quality thresholds, and outputs of the PanSolid CLC ploidy 
caller for the *NF2* gene were compared to the results from *NF2* dinucleotide 
marker PCR LOH testing for these samples. @fig-24054282-nf2-loh shows an 
example of copy-neutral LOH detected by both PanSolid and *NF2* PCR for a 
Schwannoma sample (24054282, panel: v2SchwannAll_PS). As with the WGS results,
the annotations by the CLC ploidy caller were manually reviewed. There were
3 cases in which the analyst and the ploidy caller disagreed
(@tbl-nf2-discrepant-results). In each case
the ploidy caller had categorised the *NF2* locus as having a biallelic 
deletion, with no LOH present according to the logic in @tbl-clc-ploidy-states,
whilst the SNP frequency and log2 dosage were consistent with mono-allelic 
chromosome 22 loss (@fig-24044746-loh-false-negative).

1 sample had two calls - 24031162 - this was due to a deletion on a background
of LOH.

```{r}
#| label: tbl-nf2-discrepant-results
#| tbl-cap: "Discrepant ploidy predictions"
#| echo: FALSE

nf2_loh_discrepant_results <- pansolid_vs_nf2_loh_with_qc |> 
  filter(loh_status == "No" & analyst_result == "LOH") |> 
  select(labno, ploidy_state, 
         loh_status, check_1,
         pcr_median_loh, pcr_loh) |> 
  rename(`DNA number` = labno,
         `CLC ploidy state` = ploidy_state,
         `CLC LOH status` = loh_status,
         `NF2 PCR median peak reduction (%)` = pcr_median_loh, 
         `NF2 PCR result` = pcr_loh,
         `Manual review` = check_1)

knitr::kable(nf2_loh_discrepant_results)

```

```{r}
#| label: tbl-nf2-results-with-qc
#| tbl-cap: "PanSolid NGS vs NF2 LOH PCR results with quality filters"
#| echo: FALSE

tbl_nf2_results_with_qc <- pansolid_vs_nf2_loh_with_qc |> 
  group_by(ploidy_state, loh_status, analyst_result, pcr_loh) |> 
  count() |> 
  arrange(desc(n)) |> 
  janitor::adorn_totals() |> 
  rename("CLC ploidy state" = ploidy_state,
         "CLC LOH status" = loh_status,
         "NF2 PCR result" = pcr_loh,
         "Samples" = n)

knitr::kable(tbl_nf2_results_with_qc)

```

```{r}
#| label: tbl-nf2-metrics-with-qc
#| tbl-cap: "PanSolid NGS vs NF2 LOH PCR metrics with quality filters"
#| echo: FALSE

nf2_pipeline_results <- pansolid_vs_nf2_loh_with_qc |> 
  group_by(outcome_pipeline) |> 
  count(outcome_pipeline, .drop = FALSE) 

nf2_pipeline_se_sp <- make_se_sp_table(nf2_pipeline_results$n) |> 
  mutate(category = "Ploidy caller") |> 
  relocate(category, .before = `True positives`) 

nf2_combined_results <- pansolid_vs_nf2_loh_with_qc |> 
  group_by(outcome_combined) |> 
  count(outcome_combined, .drop = FALSE) 

nf2_combined_se_sp <- make_se_sp_table(nf2_combined_results$n) |> 
  mutate(category = "Ploidy caller with manual review") |> 
  relocate(category, .before = `True positives`) 

nf2_sens_spec <- rbind(nf2_pipeline_se_sp,
                       nf2_combined_se_sp) |> 
  rename(`Analysis` = category)

kable(nf2_sens_spec)

```

```{r}
#| label: nf2-loh-image
#| include: FALSE

path_24054282 <- paste0(image_folderpath,
                        "24054282_nf2_loh.png")

caption_24054282 <- "Results for sample 24054282 (v2SchwannAll_PS) tested 
on both PanSolid NGS (top panel) and fragment PCR for *NF2* LOH. 
PanSolid NGS identified copy neutral
LOH for chromosome 22, with a clear disruption of the sample SNP profile
 (black arrows). This was confirmed by 3 dinucleotide markers on the fragment
PCR which showed a reduction of signal for a single allele in the tumour DNA 
(blue traces) versus the DNA from blood (red traces). Fragment PCR was 
uninformative for marker D22S268, hence these results are not shown."

```

![`r caption_24054282`](`r path_24054282`){#fig-24054282-nf2-loh height=5in}

```{r}
#| label: loh-false-negative-image
#| include: FALSE

path_24044746 <- paste0(image_folderpath,
                        "24044746_loh_false_negative.png")

caption_24044746 <- "For this sample (24044746, panel: v2SchwannAll_PS)
the ploidy caller categorised chromosome 
22 as a region of “bi-allelic deletion”, without LOH (see table inset), whilst 
*NF2* fragment PCR for the same sample showed significant LOH. The whole genome
plot showed a clear deletion of 22q, and a deletion of NF2 was reported by 
the PanSolid CNV caller."

```

![`r caption_24044746`](`r path_24044746`){#fig-24044746-loh-false-negative height=5in}

{{< pagebreak >}}

## Comparison to *MLH1*, *MSH2* and *MSH6* NGS LOH testing {#sec-results-mmr-ngs}

DNA from 4 colorectal cancer samples was also tested on the PanSolid enrichment.
These DNA samples had previously tested at the North West GLH on the 
tumour Lynch (tLynch) panel of the QIAseq Merged
enrichment using a Microsoft Excel-based method for LOH detection
(described in [DOC3339]{custom-style="Strong"}) in the MMR genes *MLH1*,
*MSH2* and *MSH6*. There was complete concordance between the two methods for
each gene, shown in @tbl-pansolid-vs-merged.

```{r}
#| label: tbl-pansolid-vs-merged
#| tbl-cap: "PanSolid MMR gene results"
#| echo: FALSE

merged_tlynch_results <- read_excel(path = paste0(data_folderpath,
                                             "validation/DOC6567_deletions/",
                                             "raw/qiaseq_merged/",
                                             "qiaseq_merged_tlynch_results.xlsx"),
                               col_types = c("text", "text", "text", 
                                             "text", "text"))

pansolid_vs_merged <- del_val_collated_loh |> 
  inner_join(merged_tlynch_results,
             join_by("labno" == "labno",
                     "gene" == "gene"))  |> 
  mutate(outcome = case_when(
    loh_status == "Yes" & merged_result == "Significant LOH" ~"true_positive",
    loh_status == "No" & merged_result == "No significant LOH" ~"true_negative",
    loh_status == "Yes" & merged_result == "No significant LOH" ~"false_positive",
    loh_status == "No" & merged_result == "Significant LOH" ~"false_negative"
  ))

tbl_pansolid_vs_merged <- pansolid_vs_merged |> 
  select(labno, gene, ploidy_state, loh_status, 
         check_1, 
         merged_result) |> 
  mutate(gene = factor(gene, levels = c("MLH1", "MSH2", "MSH6"))) |> 
  arrange(labno, gene) |> 
  rename(`DNA number` = labno,
         `Gene` = gene,
         `CLC ploidy state` = ploidy_state,
         `PanSolid LOH status` = loh_status,
         `Manual review` = check_1,
         `Merged LOH status` = merged_result)

kable(tbl_pansolid_vs_merged)

```

{{< pagebreak >}}

## Repeat testing {#sec-results-repeat-testing}

To assess repeat variation of the method, 3 DNA samples were tested on 3 different
worksheets. All 3 samples were from Schwannoma tumours with results from *NF2*
PCR LOH testing: 24018518, 24045597 and 24054282 (v2aSchwannAll_PS). These are
different samples than the samples used in the validation of gene amplification
detection ([DOC6283]{custom-style="Strong"}). Different samples were used because
several replicates in the original repeatability data fell below the 
`r percent_138x_qc_threshold`% coverage at 138x threshold, which was only 
established during [INC9967]{custom-style="Strong"} after 
the validation of amplification detection.

```{r}
#| label: repeat-data
#| include: FALSE

repeated_samples <- c("24018518", "24045597", "24054282")

repeat_data <- del_val_collated_del_genes |> 
  filter(labno %in% repeated_samples) |> 
  mutate(fold_change_uom = case_when(
    min_region_fold_change >= 1 ~change(min_region_fold_change, from = "fcgain",
                                        to = "fcloss"),
    TRUE ~min_region_fold_change))

```

```{r}
#| label: calculate-uom
#| include: FALSE

all_sd_table <- group_sd(repeat_data, labno, gene, fold_change_uom)
  
all_sd <- round(pool_sd(all_sd_table), 3)

del_uom <- round(define_uom(all_sd, 2), 3)

```

### Deletion detection

Gene fold changes 
greater than 1 were converted to the fold change loss equation, and the
standard deviations were calculated for each gene within each series of DNA
replicates. The pooled standard deviations and
uncertainty of measurement were then calculated (@tbl-uom), demonstrating that for 
this dataset, a fold change measurement below -1 has an uncertainty of 
measurement of ±`r del_uom` (± 2 x `r all_sd`) at a confidence level
of 95%.

For each sample 

Notably sample 24018518 had 5 genes (*FGFR3*, *MUTYH*, *RAD51C*, *RNF43* and
*STK11*) which fold changes below the `r deletion_fc_threshold` threshold in the
second replicate only. The cause of this discrepancy was likely the increased
signal-adjusted noise (0.43) for this replicate. However, the p value for each
region was above 0.05, and consequently these regions were not identified by the
pipeline as significant CNVs. This means that in a clinical scenario they would
not be analysed or reported.

```{r}
#| label: tbl-uom
#| tbl-cap: "Standard deviation and uncertainty of measurement"
#| echo: FALSE

tbl_uom <- tribble(
    ~"Metric", ~"Value",
    "Standard deviation of gene fold changes", all_sd,
    "95% Uncertainty of Measurement", del_uom)

knitr::kable(tbl_uom)

```

```{r}
#| label: repeat-plot-functions
#| include: FALSE

repeat_data_long <- repeat_data |> 
  select(labno, labno_suffix_worksheet, gene,
         min_region_fold_change, max_region_fold_change) |> 
  pivot_longer(
    cols = c(min_region_fold_change, max_region_fold_change),
    names_to = "fold_change_type",
    values_to =  "fold_change"
  ) |> 
  mutate(pansolid_result = case_when(
           fold_change <= deletion_fc_threshold ~"deletion",
           fold_change > deletion_fc_threshold ~"no deletion"
         ),
         pansolid_result = factor(pansolid_result,
                                  levels = c("no deletion", "deletion")),
         fold_change_mod = case_when(
           fold_change >= 1 ~change(fold_change, from = "fcgain",
                                    to = "fcloss"),
           TRUE ~fold_change))
  
draw_repeat_plot <- function(df = repeat_data_long, labno) {
  
  plot <- df |> 
    filter(labno == {{ labno }}) |> 
    ggplot(aes(x = labno_suffix_worksheet, y = fold_change)) +
      annotate('rect', xmin = 0, xmax = 4, ymin = -1, 
             ymax = 1, fill='white') +
      geom_hline(yintercept = 1, colour = "grey") +
      geom_hline(yintercept = -1, colour = "grey") +
    geom_hline(yintercept = deletion_fc_threshold, linetype = "dashed") +
      geom_line() +
      geom_point(shape = 21, aes(fill = pansolid_result)) +
    scale_fill_manual(values = c("white", "red")) +
    theme_bw() +
      theme(axis.text.x = element_blank(),
            legend.position = "bottom") +
      scale_y_continuous(limits = c(-2, 2), breaks = seq(-2, 2, by = 1)) +
      facet_wrap(~gene) +
      labs(x = "Replicate", y = "Fold change (loss or gain equation)",
           title = as.character(labno), fill = "PanSolid result")
  
  return(plot)
  
}

draw_repeat_plot2 <- function(df = repeat_data_long, labno) {
  
  plot <- df |> 
    filter(labno == {{ labno }}) |> 
    ggplot(aes(x = labno_suffix_worksheet, y = fold_change_mod)) +
    geom_hline(yintercept = deletion_fc_threshold, linetype = "dashed") +
      geom_line() +
      geom_point(shape = 21, aes(fill = pansolid_result)) +
    scale_fill_manual(values = c("white", "red")) +
    theme_bw() +
      theme(axis.text.x = element_blank(),
            legend.position = "bottom") +
      scale_y_continuous(limits = c(-2, 0), breaks = seq(-2, 2, by = 1)) +
      facet_wrap(~gene, ncol = 7) +
      labs(x = "Replicate", y = "Fold change (loss equation)",
           title = as.character(labno), fill = "PanSolid result")
  
  return(plot)
  
}


```

```{r}
#| label: fig-repeat-24018518-fc-loss
#| fig-cap: "24018518 repeatability results"
#| echo: FALSE
#| fig-width: 6
#| fig-height: 7

fig_repeat_24018518_loss <- draw_repeat_plot2(df = repeat_data_long,
                 labno = "24018518")

fig_repeat_24018518_loss

```

```{r}
#| label: fig-repeat-24045597-fc-loss
#| fig-cap: "24045597 repeatability results"
#| echo: FALSE
#| fig-width: 6
#| fig-height: 7

fig_repeat_24045597_loss <- draw_repeat_plot2(df = repeat_data_long,
                 labno = "24045597")

fig_repeat_24045597_loss

```

```{r}
#| label: fig-repeat-24054282-fc-loss
#| fig-cap: "24054282 repeatability results"
#| echo: FALSE
#| fig-width: 6
#| fig-height: 7

fig_repeat_24054282_loss <- draw_repeat_plot2(df = repeat_data_long,
                 labno = "24054282")

fig_repeat_24054282_loss

```

{{< pagebreak >}}

### Ploidy state detection

```{r}
#| label: loh-repeatability
#| include: FALSE

repeat_data_loh <- del_val_collated_loh |> 
  filter(labno %in% repeated_samples) |> 
  select(-c(comment_present, analyst_result, analyst_comment))

make_loh_repeat_table <- function(labno_input) {
  
  df <- repeat_data_loh |> 
  filter(labno == labno_input) |> 
  select(worksheet, gene, ploidy_state) |> 
  pivot_wider(id_cols = gene,
              names_from = worksheet,
              values_from = ploidy_state)
  
  return(df)
  
}

```

```{r}
#| label: tbl-loh-repeat-24018518
#| tbl-cap: "24018518 ploidy caller results"
#| echo: FALSE

kable(make_loh_repeat_table("24018518"))

```

```{r}
#| label: tbl-loh-repeat-24045597
#| tbl-cap: "24045597 ploidy caller results"
#| echo: FALSE

kable(make_loh_repeat_table("24045597"))

```

```{r}
#| label: tbl-loh-repeat-24054282
#| tbl-cap: "24054282 ploidy caller results"
#| echo: FALSE

kable(make_loh_repeat_table("24054282"))

```

```{r}
#| label: ncc-repeat-data
#| echo: FALSE

make_ncc_rep_plot <- function(labno_input, yaxis_title) {
  
  plot <- del_val_collated_pred_ncc |> 
    filter(labno == labno_input) |> 
    ggplot(aes(x = worksheet, y = pred_ncc)) +
    geom_point(shape = 21, size = 2) +
    ylim(0, 100) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90)) +
    labs(x = "", y = yaxis_title,
         title = paste0(labno_input))
  
  return(plot)
  
}

ncc_24018518 <- make_ncc_rep_plot("24018518", "Predicted NCC (%)")

ncc_24045597 <-make_ncc_rep_plot("24045597", "")

ncc_24054282 <- make_ncc_rep_plot("24054282", "")
  
ncc_repeat_plot <- ncc_24018518 + ncc_24045597 +
  ncc_24054282 + plot_layout(ncol = 3)

ncc_repeat_plot

```


{{< pagebreak >}}

## Limit of detection {#sec-results-lod}

DNA from two samples with WGS results was mixed
together to simulate different levels of NCC as a limit of detection experiment. 
Dilutions were prepared on worksheet WS150454 and tested on the PanSolid
enrichment on WS150465.
The first DNA sample (24026628, v2PANSOLID) was
from a glioma FFPE sample. WGS on fresh frozen tissue from the same
pathology block (24028153, R24-0QQJ) had detected a biallelic loss of *CDKN2A*, 
a monoallelic loss of the proximal section of chromosome 9q, and a 
monoallelic loss of most of chromosome 10q, including the *PTEN* gene
(@fig-lod-wgs-plots).
The second DNA sample
was from an inflammatory myofibroblastic tumour (24053299, v2PANSOLID) 
with no copy number changes
detected on chromosomes 9 or 10 on WGS (24058699, R24-1H6C). WGS detected overall 
genome ploidies of 2 and 1.9 for thes two tumours, respectively. The Ccube
algorithm within the WGS analysis pipeline detected an NCC 
of 84% for sample 24028153, and an NCC of less than 6% for 24058699, 
indicating the sample 
was mostly composed of normal tissue.
DNA mixes were prepared to simulate NCC states of 60%, 40% and 20%, 
accounting for the 16% proportion 
of DNA from normal cells in the original undiluted glioma sample.

![Limit of detection samples](`r paste0(image_folderpath, "lod_wgs_plots.png")`){#fig-lod-wgs-plots}

The results for chromosome 9 are shown in @fig-lod-chr9, demonstrating that the
biallelic *CDKN2A* loss could be detected as low as the 20% simulated NCC
sample. However, for chromosome 10 there was a false positive result for 
part of the q arm, including *PTEN*, when no glioma sample was added
(@fig-lod-chr10). Consequently, whilst there was a pattern of copy loss extending for
the majority of chromosome 10q, this could not reliably be differentiated 
from the background when the simulated NCC fell below 60%. As shown in 
@fig-chr9-lod-fold-change-plot, the results for *CDKN2A* and
*CDKN2B* broadly follow the trajectory predicted for a biallelic deletion. 
On the other hand, a similar relationship with the predicted values for a 
monoallelic deletion is only observed for certain genes on chromosome 10q
(*BMPR1A*, *FGFR2* and *SUFU*) but not for *PTEN* 
(@fig-chr10-lod-fold-change-plot).

```{r}
#| label: lod-results
#| include: FALSE
#| warning: FALSE

lod_target_folder <- paste0(config::get("data_folderpath"),
                            "validation/DOC6567_deletions/raw/",
                            "pansolid_ngs/final_format/v2PANSOLID/",
                            "Unannotated_Files/")

ncc_84 <- read_excel(path = paste0(lod_target_folder,
                         "Results_SNVs_Indels-WS150465_24026628a_S30_R1_001.xlsx"),
           sheet = "CNV Targets Merged") |> 
  mutate(id = "84% NCC; 100% glioma sample") |> 
  janitor::clean_names()

ncc_60 <- read_excel(path = paste0(lod_target_folder,
                         "Results_SNVs_Indels-WS150465_24026628b_S36_R1_001.xlsx"),
           sheet = "CNV Targets Merged") |> 
  mutate(id = "60% NCC; 71% glioma sample") |> 
  janitor::clean_names()

ncc_40 <- read_excel(path = paste0(lod_target_folder,
                         "Results_SNVs_Indels-WS150465_24026628c_S42_R1_001.xlsx"),
           sheet = "CNV Targets Merged") |> 
  mutate(id = "40% NCC; 53% glioma sample") |> 
  janitor::clean_names()

ncc_20 <- read_excel(path = paste0(lod_target_folder,
                         "Results_SNVs_Indels-WS150465_24026628d_S48_R1_001.xlsx"),
           sheet = "CNV Targets Merged") |> 
  mutate(id = "20% NCC; 24% glioma sample") |> 
  janitor::clean_names()

ncc_00_file <- list.files(path = lod_target_folder,
           pattern = "Results_SNVs_Indels-WS145901_24053299.*.xlsx",
           full.names = TRUE)

ncc_00 <- read_excel(path = ncc_00_file,
           sheet = "CNV Targets Merged") |> 
  mutate(id = "0% NCC; 0% glioma sample") |> 
  janitor::clean_names()

lod_df <- ncc_84 |> 
  select(chromosome, region, fold_change_adjusted, regional_fold_change, id) |> 
  rbind(ncc_60|> 
  select(chromosome, region, fold_change_adjusted, regional_fold_change, id)) |> 
  rbind(ncc_40|> 
  select(chromosome, region, fold_change_adjusted, regional_fold_change, id)) |> 
  rbind(ncc_20|> 
  select(chromosome, region, fold_change_adjusted, regional_fold_change, id)) |> 
  rbind(ncc_00|> 
  select(chromosome, region, fold_change_adjusted, regional_fold_change, id)) |> 
  mutate(id = factor(id, levels = c("84% NCC; 100% glioma sample",
                                    "60% NCC; 71% glioma sample", 
                                    "40% NCC; 53% glioma sample", 
                                    "20% NCC; 24% glioma sample", 
                                   "0% NCC; 0% glioma sample")),
   pansolid_result = case_when(
    regional_fold_change <= deletion_fc_threshold ~"deletion",
    regional_fold_change > deletion_fc_threshold ~"no deletion"),
  log2 = case_when(
    fold_change_adjusted <= -1 ~foldchanger::change(fold_change_adjusted, 
                                                    from = "fcloss", to = "log2r"),
    
    fold_change_adjusted >= 1 ~foldchanger::change(fold_change_adjusted, 
                                                    from = "fcgain", to = "log2r")))
  
lod_df_with_coordinates <- extract_pansolid_cnv_coordinates(df = lod_df,
                                                            cnv_coord_col = region)

```

```{r}
#| label: fig-lod-chr9
#| fig-cap: "Limit of detection for chromosome 9"
#| echo: FALSE
#| fig-width: 6
#| fig-height: 7

chr9_lod_plot <- lod_df_with_coordinates |> 
  filter(chromosome == 9) |> 
  ggplot(aes(x = start, y = log2)) +
  geom_point(shape = 21, aes(fill = pansolid_result)) +
  scale_fill_manual(values = c("red", "white")) +
  theme_bw() +
  facet_wrap(~id, nrow = 3) +
  coord_cartesian(ylim = c(-5, 5)) +
  theme(legend.position = "bottom") +
  geom_hline(yintercept = change(deletion_fc_threshold, from = "fcloss",
                                 to = "log2r"),
             linetype = "dashed") +
  labs(x = "Chromosome 9 (GRCh38)", y = "log2 ratio",
       fill = "PanSolid result",
       title = "Limit of detection results for chromosome 9")

chr9_lod_plot

```

```{r}
#| label: fig-lod-chr10
#| fig-cap: "Limit of detection for chromosome 10"
#| echo: FALSE
#| fig-width: 6
#| fig-height: 7

chr10_lod_plot <-  lod_df_with_coordinates |> 
  filter(chromosome == 10) |> 
  ggplot(aes(x = start, y = log2)) +
  geom_point(shape = 21, aes(fill = pansolid_result)) +
  scale_fill_manual(values = c("red", "white")) +
  theme_bw() +
  facet_wrap(~id, nrow = 3) +
  coord_cartesian(ylim = c(-5, 5)) +
  theme(legend.position = "bottom") +
  geom_hline(yintercept = change(deletion_fc_threshold, from = "fcloss",
                                 to = "log2r"),
             linetype = "dashed") +
  labs(x = "Chromosome 10 (GRCh38)", y = "log2 ratio",
       fill = "PanSolid result",
       title = "Limit of detection results for chromosome 10")

chr10_lod_plot
  
```

```{r}
#| label: lod-dot-plots
#| include: FALSE

lod_gene_results <- del_val_collated_del_genes |> 
  filter(labno_suffix %in% c("24026628a", "24026628b", "24026628c",
                             "24026628d", "24053299") &
           worksheet %in% c("WS150465", "WS145901")) |> 
  mutate(id = case_when(
    labno_suffix == "24026628a" ~"84% NCC; 100% glioma sample",
    labno_suffix == "24026628b" ~"60% NCC; 71% glioma sample",
    labno_suffix == "24026628c" ~"40% NCC; 53% glioma sample",
    labno_suffix == "24026628d" ~"20% NCC; 24% glioma sample",
    labno_suffix == "24053299" ~"0% NCC; 0% glioma sample"
  ),
  id = factor(id, levels = c("84% NCC; 100% glioma sample",
                                    "60% NCC; 71% glioma sample", 
                                    "40% NCC; 53% glioma sample", 
                                    "20% NCC; 24% glioma sample", 
                                   "0% NCC; 0% glioma sample")),
  simulated_ncc = case_when(
    labno_suffix == "24026628a" ~84,
    labno_suffix == "24026628b" ~60,
    labno_suffix == "24026628c" ~40,
    labno_suffix == "24026628d" ~20,
    labno_suffix == "24053299" ~0
  ),
  fold_change_max = min_region_fold_change + del_uom,
  fold_change_min = min_region_fold_change - del_uom)

```

```{r}
#| label: fig-chr9-lod-fold-change-plot
#| fig-cap: "CDKN2A and CDKN2B actual vs predicted dosage"
#| echo: FALSE
#| fig-width: 6

del_line_df <- fold_change_df |> 
  rename(simulated_ncc = ncc,
         min_region_fold_change = fold_change)

chr9_lod_dosage_plot <- lod_gene_results |> 
  filter(gene %in% c("CDKN2A", "CDKN2B")) |> 
  ggplot(aes(x = simulated_ncc, y = min_region_fold_change)) +
  geom_line(data = del_line_df,
            aes(colour = del_state), linewidth = 1) +
  scale_colour_manual(values = c( "#999999", "#999999", "#999999")) +
  geom_hline(yintercept = deletion_fc_threshold, linetype = "dashed") +
  geom_errorbar(aes(ymin = fold_change_min, ymax = fold_change_max),
                width = 2) +
  geom_point(shape = 21, size = 3, 
             fill = "white") +
  scale_x_continuous(limits = c(0, 100),
                     breaks = seq(0, 100, by = 10)) +
  scale_y_continuous(limits = c(-5, 0),
                     breaks = c(seq(-5, 0, by = 1),
                                deletion_fc_threshold),
                     minor_breaks = FALSE) +
  theme_bw() +
  theme(legend.position = "none") +
  facet_wrap(~gene) +
  labs(x = "Neoplastic cell content", y = "Fold change",
       caption = "Error bars show uncertainty of measurement") +
  annotate("text", x = 65, y = -4.5, label = "biallelic \n deletion") +
  annotate("text", x = 90, y = -2.5, label = "monoallelic \n deletion") +
  annotate("text", x = 90, y = -0.5, label = "Normal")
  
chr9_lod_dosage_plot

```


```{r}
#| label: fig-chr10-lod-fold-change-plot
#| fig-cap: "Chr10 genes actual vs predicted dosage"
#| echo: FALSE
#| fig-width: 6
#| fig-height: 7

chr10_lod_dosage_plot <- lod_gene_results |> 
  filter(gene %in% c("PTEN", "FGFR2", "SUFU", "BMPR1A")) |> 
  ggplot(aes(x = simulated_ncc, y = min_region_fold_change)) +
  geom_line(data = del_line_df,
            aes(colour = del_state), linewidth = 1) +
  scale_colour_manual(values = c( "#999999", "#999999", "#999999")) +
  geom_hline(yintercept = deletion_fc_threshold, linetype = "dashed") +
  geom_errorbar(aes(ymin = fold_change_min, ymax = fold_change_max),
                width = 2) +
  geom_point(shape = 21, size = 3, 
             fill = "white") +
  scale_x_continuous(limits = c(0, 100),
                     breaks = seq(0, 100, by = 10)) +
  scale_y_continuous(limits = c(-5, 2),
                     breaks = c(seq(-5, 2, by = 1),
                                deletion_fc_threshold),
                     minor_breaks = FALSE) +
  theme_bw() +
  theme(legend.position = "none") +
  facet_wrap(~gene, nrow = 2, ncol = 2) +
  labs(x = "Neoplastic cell content", y = "Fold change",
       caption = "Error bars show uncertainty of measurement") +
  annotate("text", x = 65, y = -4.5, label = "biallelic \n deletion") +
  annotate("text", x = 90, y = -3.5, label = "monoallelic \n deletion") +
  annotate("text", x = 90, y = -0.5, label = "Normal")

chr10_lod_dosage_plot

```

## Quality control

23011114, 23032153, 24026811 - high noise leads to multiple deletion calls 
with low fold changes.

```{r}
#| label: quality-control
#| eval: FALSE
#| include: FALSE

ggplot(noise_and_138x, aes(x = stdev_noise, y = percent_138x)) +
  geom_point(shape = 21) +
  scale_x_continuous(limits = c(0, 1.6),
                     breaks = seq(0, 1.6, by = 0.2)) +
  theme_bw()


ggplot(noise_and_138x, aes(x = stdev_noise, y = )) +
  geom_histogram() +
  #scale_x_continuous(limits = c(0, 1.8)) +
  theme_bw() 


```

### DNA contamination {#sec-results-contamination}

During the validation, it was noticed that the SNP allele frequency plot of the 
interactive HTML allowed the detection of DNA contamination between samples.
This was initially noted in sample 24030962; the SNP frequency profile was 
similar to the profiles from the limit of detection experiment, when DNA from 
two patients was deliberately mixed together. Microsatellite instability 
testing on 24030962 with the OncoMate™ MSI Dx kit (Promega) showed
the presence of additional alleles at two 
pentanucleotide markers, indicating that a contaminating sample comprised 
approximately 10% of the total DNA (@fig-24030962-dna-contamination). 
Following this discovery, all the
samples in the cohort were reviewed: 2 further samples (24030945 and 
24054291) were found to have similar profiles, and were excluded from the 
validation analysis. The signal-adjusted noise and percentage coverage above
138X were of acceptable quality for each sample.
This demonstrates that visual inspection of PanSolid 
pipeline results can detected DNA contamination at least as low as 10%, and
the source of contamination is being followed up as a quality incident
[INC10288]{custom-style="Strong"}.

```{r}
#| label: dna-contamination-image
#| include: FALSE

path_24030962 <- paste0(image_folderpath,
                        "24030962_dna_contamination.png")

caption_24030962 <- "The results for sample 24030962, which showed a dispersed
SNP frequency profile on PanSolid NGS, indicative of DNA contamination. 
Microsatellite instability (MSI) testing of the same DNA showed evidence of 
additional low-level alleles (black arrows)."

```

![`r caption_24030962`](`r path_24030962`){#fig-24030962-dna-contamination height=5in}

{{< pagebreak >}}

# Discussion

```{r}
#| label: pansolid-bed-bp
#| include: FALSE

pansolid_bed_bp <- sum(target_df_with_coordinates$target_size_bp)

haploid_genome_bp <- (3.2*10^9)

```

## Whole genome sequencing

Detection of gene deletions with the PanSolid pipeline compares favourably with
WGS using the Manta tool, with sensitivity and specificity values of 72.9% 
and 91.2%. 
There is also close overall agreement for the detection of large
chromosomal changes, which is impressive considering that the total target 
regions specified in the PanSolid BED file sum to 
`r round(pansolid_bed_bp/1000, 1)` kb, which is only
`r round((pansolid_bed_bp / haploid_genome_bp)*100, 2)`% of the human genome.
@tbl-pipeline-metrics summarises other key differences between the two 
approaches.

A key source of false positives and
false negatives in deletion detection were discrepancies relating to 
characterisation of ploidy. For example, a glioma sample was tested which had
near whole-genome haploidy with normal dosage of certain chromosomes, including
chromosome 7 (24062632). This karyotype is often observed in glioma samples
[@baker2020; @ahrendsen2022] and this sample was deliberately tested to 
understand how the PanSolid CLC pipeline would classify near-whole-genome loss
of chromosome material. The PanSolid pipeline identified LOH 
across the sample's genome, 
but did not identify genes as being deleted. 

The Genomics England WGS pipeline uses the Canvas algorithm for 
ploidy calling, which includes the prediction of whole genome ploidy and 
was was optimised using
a cohort of tumour-normal samples with known ploidy and NCC values
(@roller2016, supplementary information, page 17). Conversely, the CLC Detect
Regional Ploidy tool used by the PanSolid pipeline does not include a 
prediction of whole genome ploidy.


This allows Canvas to more
accurately deconvolute the combination of levels of NCC, ploidy and tumour
heterogeneity within the sample, whilst the PanSolid pipeline is restricted by
only using tumour FFPE material. 

This mis-prediction of ploidy also led to false
positive results from the PanSolid pipeline in tumours with high ploidy. A 
similar scenario was described by @gardina2008: when ploidy was not accounted for,
SNP-array analysis mistakenly reported a loss of chromosome 10 in 
several tetraploid glioblastoma samples which in fact had chromosome 10 trisomy, 
due to the relative dosage of chromosome 10 versus the rest the polyploid genome.

```{r}
#| label: tbl-pipeline-metrics
#| tbl-cap: "Bioinformatic pipeline details"
#| echo: FALSE

pipeline_metric_tbl <- tibble::tribble(
  ~"",         ~"PanSolid NGS", ~"Whole genome sequencing",
  "Sample(s)",   "FFPE tumour sample",   "Paired fresh frozen tumour sample and blood sample for germline DNA",
  "Library preparation", "QIAseq panel enrichment", "Whole genome amplification",
  "Pipeline software", "Analysis in QIAgen CLC Genomics Workbench; visualisation using Python", "Bespoke",
  "CNV caller",  "CLC CNV Detection Tool", "Germline CNVs: DRAGEN CNV; Somatic CNVs: Canvas",
  "Ploidy caller", "CLC Regional Ploidy Tool", "Canvas",
  "NCC calculated", "Yes - by Regional Ploidy Tool", "Yes - by Canvas and Ccube",
  "Whole genome ploidy calculated", "No", "Yes - by Canvas"
)

knitr::kable(pipeline_metric_tbl)

```

Even accounting for the differences in ploidy calculation, there were still
discrepant results between PanSolid CLC and WGS analysis for monoallelic gene
losses. Manual inspection of
the HTML files for each result showed that in each case the correct result 
could be interpreted from viewing the log2 ratios and the SNP track 
simultaneously, which would prevent these results being reported in a clinical
service. During the optimisation phase of the project, the fold change
threshold was deliberately set to be permissive, with the intention that this
would bias the pipeline towards false positives rather than false negatives.

Can we confirm CDKN2A biallelic loss?

The fold change threshold was deliberately set to be permissive. Manual 
review of detected CNVs then increased the specificity, however it did not 
increase the sensitivity. This is because often false negatives were due to
certain genes being slighly above the fold change threshold when whole chromosome
or chromosome arm losses were seen. It is not realistic to expect scientists to
remember the chromosomal locations of 37 different genes and to be able to 
manually correct where the pipeline has omitted a gene deletion result.
Consequently, manual review reduces the number of false positives, but will not
reduce the low number of false negatives.

@glodzik2023 also reported discrepancies in ploidy prediction between targeted
NGS and WGS.

## ddPCR

@mcfadden2023 reported a sensitivity and specificity of 94% and 90% when using 
ddPCR for CDKN2A deletion detection in 28 FFPE samples, using a copy number 
threshold of 1.7 with a singleplex assay [@mcfadden2023], and then sensitivity
and specificity of 
80% and 100% using a threshold of 1.6 in 17 different samples [@mcfadden2024].

In the ERBB2 validation the range varied from 0.77-6 (median: 1.61) in 
cobas-extracted controls.

## NF2 LOH PCR

The ploidy caller can correctly identify when there is a deletion on a background
of copy neutral LOH, but also may switch between ploidy states when there
is only one present.

Determining LOH by PCR is a well-established technique; a relative reduction in
peak height of at least 30% is required to classify a locus as having 
LOH [@wallace2004]. 

## QIAseq Merged Panel

The QIAseq merged panel analyses 84 SNPs in and around the *MSH2* and *MSH6* 
genes on chromosome 2 (GRCh37, chr2:47593094-48199845) and 62 SNPs in and around the 
*MLH1* gene on chromosome 3 (GRCh37, chr3:37016953-37141732).

Comparatively the LOH genes on PanSolid analysis may have only a few or no SNPs
within the gene region. This is due to the design of the PanSolid enrichment, 
and raises the potential that a focal region of copy neutral LOH could be 
missed by this method. However, this is biologically unlikely, as LOH regions 
are usually several Megabases in size.

The resolution of the ploidy caller depends on the SNPs present in the sample.

The QIAseq merged panel does not provide results for the *PMS2* gene, so there
are no gold standard results for comparison with PanSolid. Analysis of *PMS2* is
complicated by the presence of 15 pseudogenes which presents a technical
challenge for confirming the coordinates of any apparently CNV [@blount2018].

## Small and intragenic deletions

The method was optimised for whole gene deletions, although intragenic deletions
can also be detected. The ability to detect intragenic deletions depends on the 
size of the deletion, the fold change of the affected targets and the graining 
level used, which is determined by the size of the gene. 

The pipeline may detect that a deletion is there although it can overestimate 
the size.

24067827 - MSH2 intragenic deletion detected - 7 targets impacted, which is 
below the resolution of the "coarse" graining level used for *MSH2*, 
but the fold change is so 
low (-8) that it has led to a deletion being called for 13 targets (the original 7
plus an additional 6). This patient was found to have a germline MSH2 deletion 
from exon 1-7 (R24-1SXE).

Similarly, the pipeline detected an intragenic deletion only impacting 2
targets. 24034306 - biallelic deletion of exons 4 and 5 of PTEN 
(although the call is for exons 3-5) on a background of chromosome 10 loss.

This means the pipeline can alert the analyst to the presence of
intragenic deletions, which then allows the
analyst to judge the true extent of the deletion.

## Contamination

A study by @sehn2015 showed that significant contamination above 5% 
occurred in 3% of cases, 
whilst lower level contamination may be more prevalent.

## Uncertainty of Measurement

The uncertainty of measurement of the fold change metric for deleted regions
was calculated as ±`r del_uom` at 95% confidence. Notably, this value is 
slightly higher than the value of 0.17 calculated for amplifications 
([DOC6283]{custom-style="Strong"}),
and a proportion of gene results had different CNV statuses ("deletion" vs
"no deletion") on different replicates.

This is because of the difference in the scale of the change measured: 
amplification 
detection looks for changes between the normal range of 2-10 copies and an 
amplified range which extends from 10 to many hundreds of copies. Deletion
detection, in contrast, aims to detect a reduction of only 1 or 2 copies from
a potentially unstable baseline. This is summarised in the QIAgen user 
manual for CLC:

*"The fact that the same percent-wise change in coverage (copy number) leads* 
*to a higher fold change for deletions than for amplifications means that*
*given the same amplification and deletion fold change cutoff there is a *
*higher risk of calling false positive deletions than amplifications*
*- it takes less coverage fluctuation to pass the fold change cutoff*
*for deletions."* [@qiagen2023]

```{r}
#| label: deletion-threshold-with-uom
#| include: FALSE

new_del_threshold_df <- del_val_collated_del_genes |> 
  mutate(new_result = case_when(
    min_region_fold_change <= (deletion_fc_threshold + del_uom) ~"deletion",
    min_region_fold_change > (deletion_fc_threshold + del_uom) ~"no deletion"))

new_threshold_del_results <- nrow(new_del_threshold_df[new_del_threshold_df$new_result == "deletion",])

new_threshold_normal_results <- nrow(new_del_threshold_df[new_del_threshold_df$new_result == "no deletion",])

new_threshold_del_percent <- (new_threshold_del_results / 
                                (new_threshold_del_results + 
                                      new_threshold_normal_results)) * 100

```

For the amplifications
validation, we modified the amplification fold change threshold to account for the 
uncertainty of measurement, lowering it from 3 to 2.8. 
We chose not to replicate this approach for deletion
detection, as accounting for the uncertainty of measurement in the deletion 
fold change threshold would have raised the threshold to 
`r round(deletion_fc_threshold_theoretical + del_uom, 2)`
(`r round(deletion_fc_threshold_theoretical, 2)` + `r del_uom`). Applying this 
fold change threshold to our validation cohort would have led to 
`r round(new_threshold_del_percent, 1)`%
(`r new_threshold_del_results`/`r new_threshold_del_results + new_threshold_normal_results`)
of all gene results being classed as deletions, which is an unacceptably 
high rate of false positive results.

## Limitations

The technique has the following limitations:

- The Detect Regional Ploidy tool predicts LOH with high accuracy comparative
to PCR-based (@sec-results-nf2-loh) and NGS-based methods (@sec-results-mmr-ngs).
However, due to the spacing of SNPs within the PanSolid enrichment, a focal or
intragenic region of copy neutral LOH could be missed.

- Haploidy will not be identified as a genome-wide 
loss of copy dosage (@fig-24062632-haploid-false-negative) and 
higher genome-wide ploidy states
may not be correctly characterised (@fig-24045841-false-positive-hexaploid).

- The predictions of the CNV Detection tool and the Detect Regional Ploidy tool
may contradict each other in a limited number of cases. One example is the 
*PTEN* result for 24054295 (WS146337, v2SchwannAll_PS): the CNV caller predicts
a deletion whilst the ploidy caller predicts a normal diploid state.

This validation has the following limitations:

- The sample cohort is composed mainly of central nervous system 
tumours (@tbl-cancer-types) and hence had higher numbers of deletions
impacting these types of cancer.

- The repeatability tests were performed before the
75% threshold for panel coverage at 138X was decided on 
(@sec-results-repeat-testing). As a result the calculated uncertainty of 
measurement value may be an overestimate of the true value.

- An intra-control normalisation was not done.

- No true positive or true negative samples were tested for *PMS2* LOH.

- Only a single reference gene was used for ddPCR.

- Positive controls for MMR gene LOH were not sourced. Instead, samples were
used which had been sequenced with a different QIAseq enrichment, which is not
a truly orthogonal method to PanSolid.

## Overall performance of CNV detection using PanSolid NGS 

The validation of detection of deletions and ploidy status is the final 
component of the validation of CNVs on the PanSolid enrichment and 
pipeline (@tbl-previous-validations). 
This validation project has used multiple comparative techniques to assess
the test's capabilities from a number of angles (@tbl-pansolid-cnv-metrics).

```{r}
#| label: tbl-pansolid-cnv-metrics
#| tbl-cap: "PanSolid CNV detection"
#| echo: FALSE

tbl_pansolid_cnv_metrics <- read_excel(path = paste0(data_folderpath,
                         "validation/DOC6567_deletions/excel_spreadsheets/",
                         "pansolid_cnv_validation_summary.xlsx"))

kable(tbl_pansolid_cnv_metrics)

```

# Review of test requirements

The test requirements specified in @sec-requirements have been met:

**Results:** the test should provide clear results for the presence of 
whole-gene deletion in the `r length(del_genes)` specified TSGs. The test
should also provide results for the ploidy state, including copy-neutral
LOH, of the following genes:
*MSH2*, *MSH6*, *MLH1*, *PMS2*, *LZTR1*, *SMARCB1* and *NF2*.

Clear results for each gene are provided in the Excel output of the pipeline.

**Analytical validity:** the test should have a defined sensitivity and 
specificity, calculated by comparison with orthogonal methods.

The PanSolid pipeline has been compared
to WGS and ddPCR for deletion detection, and to *NF2* PCR and QIAseq NGS for 
LOH detection. The sensitivity and specificity values for these comparisons
are shown in @tbl-pansolid-cnv-metrics.

**Dosage accuracy:** it should be shown how accurate the test is at detecting 
monoallelic and biallelic deletions, in samples with a range of NCC values.

The sensitivities of the PanSolid pipeline for detecting biallelic and monoallelic deletions in comparison to WGS for diploid samples are 
`r substr(bi_mono_allelic_results_diploid[1, 5], 1,3)`% and
`r substr(bi_mono_allelic_results_diploid[2, 5], 1, 4)`%, respectively. The NCC values 
for these samples ranged from
`r min(pansolid_vs_wgs_outcomes$calculated_tumour_content, na.rm = TRUE)`
to
`r max(pansolid_vs_wgs_outcomes$calculated_tumour_content, na.rm = TRUE)`
(@sec-results-bi-mono-deletions).

**Quality control:** the test should have clear quality control thresholds
for deciding when the test results should be reported and when the test has 
failed.

Consistent with current service thresholds for amplification detection, the 
detection of deletions and ploidy states requires signal-adjusted noise metrics
below 1, and optimally below 0.7, and the percentage coverage at 138X should
be 75% or greater. The SNP allelic frequency profile can identify DNA 
contamination down to at least 10% (@sec-results-contamination), 
and should be checked for every sample.

**Variability:** the test should have defined intra-run variation 
(repeatability) and inter-run variability (reproducibility) for detection of 
deletions. Analysis of this variation should then be used to derive the 
uncertainty of measurement for the test.

The variation for fold change is
`r all_sd`, and the uncertainty of measurement for fold
change is `r del_uom` at 95% confidence (@sec-results-repeat-testing).

**Visualisation:** the results should be presented in a clear and visual 
manner.

A new Excel visualisation and HTML output were designed for viewing
deletion, amplification and ploidy state results from the PanSolid 
pipeline (@fig-24021613-visualisation).

**Analysis:** there should be a clear procedure for analysis for gene 
deletions by laboratory staff.

[DOC6261: Somatic Copy Number Variant Analysis on the PanSolid Cancer Panel]{custom-style="Strong"} 
will be updated to reflect the addition of deletion and ploidy state detection
and the new result visualisation.

# Requirements for clinical implementation

Given the findings of this validation, the PanSolid NGS pipeline for detection
of gene deletions and ploidy states is ready for clinical implementation, with 
the following requirements:

Any deletion calls from the PanSolid pipeline which are to be clinically 
reported should be viewed in the HTML
file to check the log2 and SNP allele-frequency profiles are consistent with a
deletion. This is because a proportion of deletion calls are false positives.

The outputs of the Detect Regional Ploidy tool for the 
*MSH2*, *MSH6*, *MLH1*, *PMS2*, *LZTR1*, *SMARCB1* and *NF2* should be checked
for consistency against the results shown in the HTML file, in order to 
identify the low percentage of cases where the outputs differ from 
PCR-based LOH testing.

The test has a limit of detection for biallelic deletions of at least 
20% NCC (@sec-results-lod). In practice, this may be further reduced by the
technique's uncertainty of measurement.

The test will report genome-wide copy-neutral LOH in cases of haploidy.

The ploidy caller and the CNV caller may disagree - analysts should be aware
of this.

# Conclusion

The PanSolid NGS enrichment v2 and PanSolid CLC pipeline v2.4 has been validated 
for the detection of deletions in
`r length(unique(del_val_collated_del_genes$gene))` genes, and for the prediction
of ploidy states in *MSH2*, *MSH6*, *MLH1*, *PMS2*, *LZTR1*, *SMARCB1* and *NF2*.

{{< pagebreak >}}

# References

::: {#refs}
:::

{{< pagebreak >}}

# Supplementary Information

## Panel details

```{r}
#| label: tbl-deletion-gene-targets
#| tbl-cap: "Genes on the deletion list"
#| echo: FALSE

kable(gene_target_counts)

```

## ddPCR details

```{r}
#| label: tbl-ddpcr-primers
#| tbl-cap: "ddPCR primer sequences"
#| echo: FALSE

ddpcr_primer_tbl <- tribble(
  ~`Primer name`, ~`Sequence (5'-3')`,
  "dCDKN2A_Ex3_1F", "TGTAAAACGACGGCCAGTCACTTCACACGGTCTCGCACTGGGTCCTACAGGGCCACAACTG",
  "dCDKN2A_Ex3_1R", "AAACTACGAAAGCGGGGTGG",
  "dPTEN_Ex1_2F",   "TGTAAAACGACGGCCAGTCACTTCACACGGTCTCGCACTGGCCATTTCCATCCTGCAGAAGAAGC",
  "dPTEN_Ex1_2R", "GATGATGGCTGTCATGTCTGGG"
)

knitr::kable(ddpcr_primer_tbl)

```

```{r}
#| label: ddpcr-images
#| include: FALSE

path_cdkn2a_ddpcr <- paste0(image_folderpath,
                            "ddpcr_cdkn2a.png")

path_pten_ddpcr <- paste0(image_folderpath,
                          "ddpcr_pten.png")

```

!["CDKN2A ddPCR"](`r path_cdkn2a_ddpcr`){#fig-ddpcr-cdkn2a}

!["PTEN ddPCR"](`r path_pten_ddpcr`){#fig-ddpcr-pten}
